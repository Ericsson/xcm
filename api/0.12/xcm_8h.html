<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extensible Connection-oriented Messaging (XCM): include/xcm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extensible Connection-oriented Messaging (XCM)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">xcm.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the core Extensible Connection-oriented Messaging (XCM) API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
</div>
<p><a href="xcm_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5741d65a6840a49421f076e1abc69a1c" id="r_a5741d65a6840a49421f076e1abc69a1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="separator:a5741d65a6840a49421f076e1abc69a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b41267a9d7f1c267b1ef1ff446a5d06" id="r_a8b41267a9d7f1c267b1ef1ff446a5d06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a8b41267a9d7f1c267b1ef1ff446a5d06">XCM_FD_READABLE</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="separator:a8b41267a9d7f1c267b1ef1ff446a5d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f23cfc23562bae00923bdb06e7e23" id="r_abb5f23cfc23562bae00923bdb06e7e23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#abb5f23cfc23562bae00923bdb06e7e23">XCM_FD_WRITABLE</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="separator:abb5f23cfc23562bae00923bdb06e7e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7eb63ad93365ea33cda4d5bbafc8d9" id="r_a6f7eb63ad93365ea33cda4d5bbafc8d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6f7eb63ad93365ea33cda4d5bbafc8d9">XCM_FD_EXCEPTION</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="separator:a6f7eb63ad93365ea33cda4d5bbafc8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3429d5eebf90c5572549d77a3d08f2f" id="r_aa3429d5eebf90c5572549d77a3d08f2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#aa3429d5eebf90c5572549d77a3d08f2f">XCM_SO_RECEIVABLE</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="separator:aa3429d5eebf90c5572549d77a3d08f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864b4817dbcca717b5b9778d2c6deac3" id="r_a864b4817dbcca717b5b9778d2c6deac3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a864b4817dbcca717b5b9778d2c6deac3">XCM_SO_SENDABLE</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="separator:a864b4817dbcca717b5b9778d2c6deac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6835d2d195427b0748c9c2fd782596f2" id="r_a6835d2d195427b0748c9c2fd782596f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6835d2d195427b0748c9c2fd782596f2">XCM_SO_ACCEPTABLE</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="separator:a6835d2d195427b0748c9c2fd782596f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae20ec97fe774a1d92e3fde4ec1d4aa91" id="r_ae20ec97fe774a1d92e3fde4ec1d4aa91"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect</a> (const char *remote_addr, int flags)</td></tr>
<tr class="separator:ae20ec97fe774a1d92e3fde4ec1d4aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dd2ff0e70e5658200fe574ee44eba2" id="r_ab6dd2ff0e70e5658200fe574ee44eba2"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server</a> (const char *local_addr)</td></tr>
<tr class="separator:ab6dd2ff0e70e5658200fe574ee44eba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5449c1b0818cf422cffe799872a570" id="r_abb5449c1b0818cf422cffe799872a570"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:abb5449c1b0818cf422cffe799872a570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74466386ee40c9e5992940822b4ec02" id="r_ab74466386ee40c9e5992940822b4ec02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:ab74466386ee40c9e5992940822b4ec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b0002316159f9d968c4e361c859542" id="r_a88b0002316159f9d968c4e361c859542"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept</a> (struct xcm_socket *server_socket)</td></tr>
<tr class="separator:a88b0002316159f9d968c4e361c859542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a888c879430f4fd51ccf43d6cec344" id="r_ac1a888c879430f4fd51ccf43d6cec344"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send</a> (struct xcm_socket *conn_socket, const void *buf, size_t len)</td></tr>
<tr class="separator:ac1a888c879430f4fd51ccf43d6cec344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b290a1b9e5a806c955322883481d29" id="r_a01b290a1b9e5a806c955322883481d29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive</a> (struct xcm_socket *conn_socket, void *buf, size_t capacity)</td></tr>
<tr class="separator:a01b290a1b9e5a806c955322883481d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e09a4b8705bb688ffe57f184308186e" id="r_a2e09a4b8705bb688ffe57f184308186e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want</a> (struct xcm_socket *socket, int condition, int *fds, int *events, size_t capacity)</td></tr>
<tr class="separator:a2e09a4b8705bb688ffe57f184308186e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a75d0f3a97207beb406cd6787df4" id="r_a93e6a75d0f3a97207beb406cd6787df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a93e6a75d0f3a97207beb406cd6787df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae833dd506b15de04445e3a8331ad36bf" id="r_ae833dd506b15de04445e3a8331ad36bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking</a> (struct xcm_socket *socket, bool should_block)</td></tr>
<tr class="separator:ae833dd506b15de04445e3a8331ad36bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfdb3e1a859549d686c93b32c6a6818" id="r_a6cfdb3e1a859549d686c93b32c6a6818"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6cfdb3e1a859549d686c93b32c6a6818">xcm_is_blocking</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a6cfdb3e1a859549d686c93b32c6a6818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150197cffea9d5ff610bb856b5fd2de" id="r_a6150197cffea9d5ff610bb856b5fd2de"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr</a> (struct xcm_socket *conn_socket)</td></tr>
<tr class="separator:a6150197cffea9d5ff610bb856b5fd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fefa1353b41c2445e13603e80f56336" id="r_a7fefa1353b41c2445e13603e80f56336"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a7fefa1353b41c2445e13603e80f56336">xcm_local_addr</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a7fefa1353b41c2445e13603e80f56336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the core Extensible Connection-oriented Messaging (XCM) API. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5741d65a6840a49421f076e1abc69a1c" name="a5741d65a6840a49421f076e1abc69a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5741d65a6840a49421f076e1abc69a1c">&#9670;&#160;</a></span>XCM_NONBLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_NONBLOCK&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag used in <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> </p>

</div>
</div>
<a id="a8b41267a9d7f1c267b1ef1ff446a5d06" name="a8b41267a9d7f1c267b1ef1ff446a5d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b41267a9d7f1c267b1ef1ff446a5d06">&#9670;&#160;</a></span>XCM_FD_READABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_FD_READABLE&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a readable fd event in <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a>. </p>

</div>
</div>
<a id="abb5f23cfc23562bae00923bdb06e7e23" name="abb5f23cfc23562bae00923bdb06e7e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5f23cfc23562bae00923bdb06e7e23">&#9670;&#160;</a></span>XCM_FD_WRITABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_FD_WRITABLE&#160;&#160;&#160;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a writable fd event. </p>

</div>
</div>
<a id="a6f7eb63ad93365ea33cda4d5bbafc8d9" name="a6f7eb63ad93365ea33cda4d5bbafc8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7eb63ad93365ea33cda4d5bbafc8d9">&#9670;&#160;</a></span>XCM_FD_EXCEPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_FD_EXCEPTION&#160;&#160;&#160;(1&lt;&lt;2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a exception fd event. </p>

</div>
</div>
<a id="aa3429d5eebf90c5572549d77a3d08f2f" name="aa3429d5eebf90c5572549d77a3d08f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3429d5eebf90c5572549d77a3d08f2f">&#9670;&#160;</a></span>XCM_SO_RECEIVABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_SO_RECEIVABLE&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a socket where the application likely can receive a message. </p>

</div>
</div>
<a id="a864b4817dbcca717b5b9778d2c6deac3" name="a864b4817dbcca717b5b9778d2c6deac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864b4817dbcca717b5b9778d2c6deac3">&#9670;&#160;</a></span>XCM_SO_SENDABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_SO_SENDABLE&#160;&#160;&#160;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a socket where the application likely can send a message. </p>

</div>
</div>
<a id="a6835d2d195427b0748c9c2fd782596f2" name="a6835d2d195427b0748c9c2fd782596f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6835d2d195427b0748c9c2fd782596f2">&#9670;&#160;</a></span>XCM_SO_ACCEPTABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_SO_ACCEPTABLE&#160;&#160;&#160;(1&lt;&lt;2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a socket with a pending incoming connection. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae20ec97fe774a1d92e3fde4ec1d4aa91" name="ae20ec97fe774a1d92e3fde4ec1d4aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20ec97fe774a1d92e3fde4ec1d4aa91">&#9670;&#160;</a></span>xcm_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to a remote server socket.</p>
<p>This function returns a connection socket, which is used to send messages to, and receive messages from the server.</p>
<p>In BSD Sockets terms, this call does both socket() and connect().</p>
<p>By default, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> blocks for the time it takes for the transport to determine if the named remote endpoint exists, and is responding (including any initial handshaking, key exchange etc). If the remote server socket is not yet bound, it's up to the application to retry.</p>
<p>If the XCM_NONBLOCK flag is set, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> will work in a non-blocking fashion and will always return immediately, either leaving the connection socket in a connected state, a partly connected state, or signaling an error.</p>
<p>Setting XCM_NONBLOCK will leave the connection in non-blocking mode (see <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> for details).</p>
<p>See <a class="el" href="index.html#select">Event-driven Programming Support</a> for an overview how non-blocking mode is used.</p>
<p>For non-blocking connection establishment attempts, the application may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> the query the result. It should use <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> to retrieve the needed information to be able to wait the appropriate time to make the <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> call (although it may be called at any point).</p>
<p><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> with the XCM_NONBLOCK flag set will leave the connection in non-blocking mode (see <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> for details).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>The remote address which to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Either 0, or XCM_NONBLOCK for a non-blocking connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a socket reference on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">Invalid address format.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ENOPROTOOPT   </td><td class="markdownTableBodyNone">Transport protocol not available.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EMFILE   </td><td class="markdownTableBodyNone">The limit on the total number of open fds has been reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ENOENT   </td><td class="markdownTableBodyNone">DNS domain name resolution failed.   </td></tr>
</table>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for other possible errno values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close</a> </dd></dl>

</div>
</div>
<a id="ab6dd2ff0e70e5658200fe574ee44eba2" name="ab6dd2ff0e70e5658200fe574ee44eba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dd2ff0e70e5658200fe574ee44eba2">&#9670;&#160;</a></span>xcm_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_server </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>local_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a server socket and binds it to a specific address.</p>
<p>This function creates a server socket and binds it to a specific address. After this call has completed, clients may connect to the address specified.</p>
<p>This call is the equivalent of socket()+bind()+listen() in BSD Sockets. In case remote_addr has a DNS domain name (as opposed to an IP address), a <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> call also includes a blocking name resolution (e.g. gethostbyname()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_addr</td><td>The local address to which this socket should be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a server socket reference on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EACCESS   </td><td class="markdownTableBodyNone">Permission to create the socket is denied.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EADDRINUSE   </td><td class="markdownTableBodyNone">Local socket address is already in use.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOMEM   </td><td class="markdownTableBodyNone">Insufficient memory.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">Invalid address format.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOPROTOOPT   </td><td class="markdownTableBodyNone">Transport protocol not available.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EMFILE   </td><td class="markdownTableBodyNone">The limit on the total number of open fds has been reached.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EPROTO   </td><td class="markdownTableBodyNone">A protocol error occured.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ENOENT   </td><td class="markdownTableBodyNone">DNS domain name resolution failed.   </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close</a> </dd></dl>

</div>
</div>
<a id="abb5449c1b0818cf422cffe799872a570" name="abb5449c1b0818cf422cffe799872a570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5449c1b0818cf422cffe799872a570">&#9670;&#160;</a></span>xcm_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_close </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an endpoint.</p>
<p>This function close a XCM socket, including both signaling to the far and freeing of any local resources associated with this socket.</p>
<p><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a> will not block, and applications wanting to finish any outstanding tasks on a socket in non-blocking mode should use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket to be closed, or NULL (in case <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a> is a no-operation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup</a> </dd></dl>

</div>
</div>
<a id="ab74466386ee40c9e5992940822b4ec02" name="ab74466386ee40c9e5992940822b4ec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74466386ee40c9e5992940822b4ec02">&#9670;&#160;</a></span>xcm_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xcm_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up any local resources tied to a XCM socket not owned by the caller process.</p>
<p>After a fork() call, either of the two processes (the parent, or the child) must be designated the owner of every XCM socket the parent owned.</p>
<p>The owner may continue to use the XCM socket normally.</p>
<p>The non-owner may use <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a> to free any local memory tied to this socket, without impacting the connection state in the owner process.</p>
<p>The non-owner may not call <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a> or any other XCM API call.</p>
<p>The owner may not call <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket which local resources are to be freed, or NULL (in case <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a> is a no-operation). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b0002316159f9d968c4e361c859542" name="a88b0002316159f9d968c4e361c859542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b0002316159f9d968c4e361c859542">&#9670;&#160;</a></span>xcm_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_accept </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>server_socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a pending incoming connection from the server socket's queue.</p>
<p><a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> retrieves the first connection request from the server socket's queue of pending connections.</p>
<p>In case the server socket is in non-blocking mode, the XCM connection socket returned from <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> will also be in non-blocking mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">server_socket</td><td>The server socket on which to attempt to accept one pending connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a newly created XCM connection socket on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EMFILE   </td><td class="markdownTableBodyNone">The limit on the total number of open fds has been reached.   </td></tr>
</table>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for other possible errno values. </p>

</div>
</div>
<a id="ac1a888c879430f4fd51ccf43d6cec344" name="ac1a888c879430f4fd51ccf43d6cec344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a888c879430f4fd51ccf43d6cec344">&#9670;&#160;</a></span>xcm_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_send </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>conn_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send message on a particular connection.</p>
<p>The <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> function is used to send a message out on a connection socket. A XCM connection goes from a client to a server, and this connection socket may represent either one of the two endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_socket</td><td>The connection socket the message will be sent on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A pointer to the message data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of the message in bytes. Zero-length messages are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EMSGSIZE   </td><td class="markdownTableBodyNone">Message is too large. See also <a class="el" href="index.html#xcm_attr">Generic Attributes</a>.   </td></tr>
</table>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for more errno values. </p>

</div>
</div>
<a id="a01b290a1b9e5a806c955322883481d29" name="a01b290a1b9e5a806c955322883481d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b290a1b9e5a806c955322883481d29">&#9670;&#160;</a></span>xcm_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_receive </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>conn_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive message on a particular connection.</p>
<p>The <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> function is used to receive message on a connection socket. A XCM connection goes from a client to a server, and this connection socket may represent either one of the two endpoints.</p>
<p>If the capacity of the user-supplied buffer is smaller than the actual message length, the message will be truncated and the part that fits will be stored in the buffer. The return value will be the length of the truncated message (i.e. the capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_socket</td><td>The connection socket the message will receive be on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>The user-supplied buffer where the incoming message will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity in bytes of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size (&gt; 0 bytes) of the received message, 0 if the remote end has closed the connection, or -1 if an error occured (in which case errno is set).</dd></dl>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for possible errno values. </p>

</div>
</div>
<a id="a2e09a4b8705bb688ffe57f184308186e" name="a2e09a4b8705bb688ffe57f184308186e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e09a4b8705bb688ffe57f184308186e">&#9670;&#160;</a></span>xcm_want()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_want </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the socket what events on which file descriptors it's waiting for.</p>
<p>This function is only used by event-driven application and with XCM sockets in non-blocking mode. For an overview on this subject, see <a class="el" href="index.html#select">Event-driven Programming Support</a>.</p>
<p>With <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a>, the application will inform the XCM socket what condition it's waiting for (i.e. what XCM operation it wants to perform), and in return the XCM socket will provide a set of file descriptors and, for each fd, information on what type of event on that fd it require to make progress. Progress can mean both progress toward the goal of reaching the application's desired socket condition, or finishing any outstanding task the XCM socket has.</p>
<p>In case any of the conditions the application is asking for are believed to be already met, the <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> call will return 0.</p>
<p>In case the XCM socket has no outstanding tasks, and the application is not asking for any operation that the XCM socket believes it can't immediate fulfill, the call will return 0.</p>
<p>The conditions specified by the application are future operation it wishes to perform on a socket (as opposed to finishing operations the socket has already accepted). For example, if an application use <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> to transmit a message, and the XCM socket accept this request (by returning 0 on the call), the application shouldn't send <a class="el" href="xcm_8h.html#a864b4817dbcca717b5b9778d2c6deac3">XCM_SO_SENDABLE</a> flag for the reason of having XCM finishing the transmission; the task of actually handing over message to the lower layer is performed by XCM regardless of the conditions specified.</p>
<p>Note that XCM may ask the application to wait for the connection's fd or fds to become writable, even if the application is waiting to receive a message. It may also ask the application to wait for the connection's fd to become readable, even if the application is attemting to send a messaging. For the quirks of <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a>, see <a class="el" href="index.html#io_waiting">Waiting for Read May Mean Waiting for Write</a>.</p>
<p>Even though the conditions for a particular connection socket are met (fd is becoming writable, for example), there's no guarantee that the <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> or <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> won't block (or in case of non-blocking mode, won't fail and set EAGAIN).</p>
<p>The XCM socket fds may only be used with select(). Supplying this fd to any other OS calls (such as setsockopt(2), read(2) etc) is prohibited.</p>
<p>The information received on which fd to use, and what events on that fd are relevant for the connection socket in its current state, are only valid until more xcm_* calls are made on this socket. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for more information.</p>
<p>The fd is an positive integer, unique within this process.</p>
<p>The condition parameter is a bitmask, with the bits being <a class="el" href="xcm_8h.html#aa3429d5eebf90c5572549d77a3d08f2f">XCM_SO_RECEIVABLE</a>, <a class="el" href="xcm_8h.html#a864b4817dbcca717b5b9778d2c6deac3">XCM_SO_SENDABLE</a>, and/or <a class="el" href="xcm_8h.html#a6835d2d195427b0748c9c2fd782596f2">XCM_SO_ACCEPTABLE</a>. If no bits are set, the application is not interested in anything beyond this XCM socket to finish any outstanding task.</p>
<p>Each element in the events array is an int used as a bitmask. The bitmask at position N in the events array represents the file descriptor events the XCM transport is waiting for, for fd at position N in the fds array. The bits are <a class="el" href="xcm_8h.html#a8b41267a9d7f1c267b1ef1ff446a5d06">XCM_FD_READABLE</a>, <a class="el" href="xcm_8h.html#abb5f23cfc23562bae00923bdb06e7e23">XCM_FD_WRITABLE</a> and/or <a class="el" href="xcm_8h.html#a6f7eb63ad93365ea33cda4d5bbafc8d9">XCM_FD_EXCEPTION</a>. At least one bit is always set.</p>
<p>If a socket is waiting for multiple events (for example, both readable and writable on the same fd, or readable on one fd, and writeable on another), the condition is met whenever any of the events occur (as oppose to all events).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The XCM socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The condition the application is waiting for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fds</td><td>An user-supplied array to store the fds. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>An user-supplied array of int to store the bitmask of each of the fds in the fds array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The length of the fds and events arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number (&gt;=0) of fds, or -1 if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EOVERFLOW   </td><td class="markdownTableBodyNone">The user-supplied buffer was too small to fit the socket's fds.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">The socket is not in blocking mode, or the condition bits are invalid.   </td></tr>
</table>

</div>
</div>
<a id="a93e6a75d0f3a97207beb406cd6787df4" name="a93e6a75d0f3a97207beb406cd6787df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a75d0f3a97207beb406cd6787df4">&#9670;&#160;</a></span>xcm_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_finish </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to finish an ongoing non-blocking background operation.</p>
<p>This call is used by an application having issued <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> with the XCM_NONBLOCK flag set, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> call on a connection socket in non-blocking mode, wishing to finish outstanding processing related to that operation, to know if it succeeded or not.</p>
<p>In addition, <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> must be called if the conditions set by <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> are met (as signaled by select(), unless the application calls <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> on that socket. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for details.</p>
<p><a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> may be called at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The connection or server socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the connection has been successfully been established, or -1 if it has not (in which case errno is set).</dd></dl>
<p>These errno values are possible not only for <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, but also for <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EPIPE   </td><td class="markdownTableBodyNone">The connection is closed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EAGAIN   </td><td class="markdownTableBodyNone">The socket is marked non-blocking (with <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a>) and the requested operation would block.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ECONNRESET   </td><td class="markdownTableBodyNone">Connection reset by peer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ECONNREFUSED   </td><td class="markdownTableBodyNone">No-one is listening on the remote address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ECONNABORTED   </td><td class="markdownTableBodyNone">A connection has been aborted due to host-internal reasons.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EHOSTUNREACH   </td><td class="markdownTableBodyNone">Remote host is unreachable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENETUNREACH   </td><td class="markdownTableBodyNone">Network is unreachable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ETIMEDOUT   </td><td class="markdownTableBodyNone">No or lost network connectivity.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOMEM   </td><td class="markdownTableBodyNone">Insufficient memory (or other resources) to perform operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EINTR   </td><td class="markdownTableBodyNone">The operation was interrupted by a UNIX signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EPROTO   </td><td class="markdownTableBodyNone">A non-recoverable protocol error occurred.   </td></tr>
</table>

</div>
</div>
<a id="ae833dd506b15de04445e3a8331ad36bf" name="ae833dd506b15de04445e3a8331ad36bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae833dd506b15de04445e3a8331ad36bf">&#9670;&#160;</a></span>xcm_set_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_set_blocking </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabled or disabled non-blocking operation on this socket.</p>
<p>In blocking mode (which is the default), <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> calls does not return until a message has been handed over to the system (in case of send), or received from the system (in case of receive), or an error has occured (whichever happens first).</p>
<p>In non-blocking mode, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return immediately, regardless if XCM has been enable to fulfill the application's request or not.</p>
<p>Server sockets may also be set into non-blocking mode, in which case <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> won't block.</p>
<p>Connection sockets created as a result of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> may be set into non-blocking mode already from the start, by means of the <a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a> flag to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, in which case also the connection establishment process is non-blocking.</p>
<p>For an overview of the use of non-blocking mode, see <a class="el" href="index.html#select">Event-driven Programming Support</a>.</p>
<p>To set a non-blocking connection socket into blocking mode, it needs to have finished all outstanding tasks. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">should_block</td><td>Set to true for blocking operation, false for non-blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the 0 on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EAGAIN   </td><td class="markdownTableBodyNone">The connection socket has unfinished work that needs to completed before mode can be switched.   </td></tr>
</table>

</div>
</div>
<a id="a6cfdb3e1a859549d686c93b32c6a6818" name="a6cfdb3e1a859549d686c93b32c6a6818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfdb3e1a859549d686c93b32c6a6818">&#9670;&#160;</a></span>xcm_is_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xcm_is_blocking </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query whether or not a socket is in non-blocking mode.</p>
<p>For an overview of the use of non-blocking mode, see <a class="el" href="index.html#select">Event-driven Programming Support</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the true if the socket is in blocking mode, or false if it is in non-blocking mode.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking</a> </dd></dl>

</div>
</div>
<a id="a6150197cffea9d5ff610bb856b5fd2de" name="a6150197cffea9d5ff610bb856b5fd2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6150197cffea9d5ff610bb856b5fd2de">&#9670;&#160;</a></span>xcm_remote_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xcm_remote_addr </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>conn_socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the remote endpoint for this connection.</p>
<p>This operation only works for sockets representing connections.</p>
<p>The address returned is in string format, and the pointer returned is to an buffer allocated as a part of the socket state, and need not and should not be free'd by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_socket</td><td>The connection socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the remote endpoint address, or NULL if an error occurred (in which case errno is set). </dd></dl>

</div>
</div>
<a id="a7fefa1353b41c2445e13603e80f56336" name="a7fefa1353b41c2445e13603e80f56336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fefa1353b41c2445e13603e80f56336">&#9670;&#160;</a></span>xcm_local_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xcm_local_addr </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the local endpoint for this socket.</p>
<p>Just like <a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr()</a>, but returns the local endpoint address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>A server or connection socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the local endpoint address, or NULL if an error occurred (in which case errno is set). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 30 2025 11:12:41 for Extensible Connection-oriented Messaging (XCM) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
