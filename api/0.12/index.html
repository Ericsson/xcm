<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extensible Connection-oriented Messaging (XCM): Extensible Connection-oriented Messaging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extensible Connection-oriented Messaging (XCM)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Extensible Connection-oriented Messaging </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>This is the documentation for the Extensible Connection-oriented Messaging (XCM) programming APIs.</p>
<p>XCM consists of of three parts; the core API in <a class="el" href="xcm_8h.html" title="This file contains the core Extensible Connection-oriented Messaging (XCM) API.">xcm.h</a>, an address helper library API in <a class="el" href="xcm__addr_8h.html" title="This is an API for building and parsing Connection-oriented Messaging (XCM) addresses.">xcm_addr.h</a>, and the attribute access API in <a class="el" href="xcm__attr_8h.html" title="This file contains the XCM attribute access API. See Socket Attributes for an overview.">xcm_attr.h</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Mattias Rönnblom </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.12</dd></dl>
<p>The low version number is purely a result of all XCM releases being backward compatible, and thus left the major version at 0. It's not to be taken as a sign of immaturity. The API and its implementation has been stable for several years.</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>XCM provides a connection-oriented, reliable messaging service with in-order delivery. The design goal is to allow a straight-off mapping to TCP and TLS, but also allow more efficient transport for local communication.</p>
<p>XCM reuses much of the terminology (and semantics) of the BSD Sockets API.</p>
<h1><a class="anchor" id="semantics"></a>
Overall Service Semantics</h1>
<p>XCM has a client-server model. A server creates a server socket (with <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>) bound to a specific address (in case of TCP or TLS, a TCP port on a particular IP interface), after which clients may initiate connections to the server. On a successful attempt, two connection sockets will be created; one on the server side (returned from <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>), and one of the client side (returned from <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>). Thus, a server serving multiple clients will have multiple sockets; one server socket and N connection sockets, one each for every client. A client will have one connection socket for each server it is connected to.</p>
<p>Messages are always sent and received on a particular connection socket (and never on a server socket).</p>
<h2><a class="anchor" id="ordering"></a>
Ordering Guarantees</h2>
<p>In-order delivery - that messages arrive at the receiver in the same order they were sent by the sender side - is guaranteed, but only for messages sent on the same connection.</p>
<h2><a class="anchor" id="flow_control"></a>
Flow Control</h2>
<p>XCM transports support flow control. Thus, if the sender message rate or bandwidth is higher than the network or the receiver can handle on a particular connection, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> in the sender process will eventually block (or return an error EAGAIN, if in non-blocking mode). Unless XCM is used for bulk data transfer (as oppose to signaling traffic), <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> blocking because of slow network or a slow receiver should be rare indeed in practice. TCP, TLS, and UNIX domain socket transports all have large enough windows and socket buffers to allow a very large amount of outstanding data.</p>
<h1><a class="anchor" id="addressing"></a>
Addressing and Transport Selection</h1>
<p>In XCM, the application is in control of which transport will be used, with the address supplied to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> including both the transport name and the transport address.</p>
<p>However, there is nothing preventing a XCM transport to use a more an abstract addressing format, and internally include multiple "physical" IPC transport options. This model is used by the <a class="el" href="index.html#utls_transport">UTLS Transport</a>.</p>
<h2><a class="anchor" id="address_syntax"></a>
Address Syntax</h2>
<p>Addresses are represented as strings with the following general syntax: <code>&lt;transport-name&gt;:&lt;transport-address&gt;</code></p>
<p>For the UX UNIX Domain Socket transport, the addresses has this more specific form: <br  />
</p><div class="fragment"><div class="line">ux:&lt;UNIX domain socket name&gt; </div>
</div><!-- fragment --><p>The addresses of the UXF UNIX Domain Socket transport variant follow the following format: <br  />
</p><div class="fragment"><div class="line">uxf:&lt;file system path&gt; </div>
</div><!-- fragment --><p>For the TCP, TLS, UTLS and SCTP transports the syntax is: <br  />
</p><div class="fragment"><div class="line">tcp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">tls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">utls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">sctp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
</div><!-- fragment --><p>'*' is a shorthand for '0.0.0.0' (=bind to all IPv4 interfaces). '[*]' is the IPv6 equivalent.</p>
<p>For example: </p><div class="fragment"><div class="line">tcp:*:4711</div>
<div class="line">tls:192.168.1.42:4711</div>
<div class="line">tcp:[::1]:99</div>
<div class="line">tcp:[*]:4711</div>
<div class="line">tls:service:4711</div>
<div class="line">sctp:service.company.com:42</div>
</div><!-- fragment --><p>For TCP, TLS, UTLS and SCTP server socket addresses, the port can be set to 0, in which case XCM (or rather, the Linux kernel) will allocate a free TCP port.</p>
<h3><a class="anchor" id="dns"></a>
DNS Resolution</h3>
<p>For transports allowing a DNS domain name as a part of the address, the transport will attempt resoĺv the name to an IP address. A DNS domain name may resolv to zero or more IPv4 addresses and/or zero or more IPv6 addresses. XCM relies on the system's configuration to prioritize between IPv4 and IPv6.</p>
<h3><a class="anchor" id="ip_addr_format"></a>
IPv4 Address Format</h3>
<p>XCM accepts IPv4 addresses in the dotted-decimal format </p><div class="fragment"><div class="line">130.236.254.2</div>
</div><!-- fragment --><p>XCM allows only complete addresses with three '.', and not the archaic, classful, forms, where some bytes where left out, and thus the address contained fewer separators.</p>
<h1><a class="anchor" id="dpd"></a>
Dead Peer Detection</h1>
<p>XCM transports attempts to detect a number of conditions which can lead to lost connectivity, and does so even on idle connections.</p>
<p>If the remote end closes the connection, the local <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return 0. If the process on the remote end crashed, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return -1 and set errno ECONNRESET. If network connectivity to the remote end is lost, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return -1 and errno will be set to ETIMEDOUT.</p>
<h1><a class="anchor" id="error_handling"></a>
Error Handling</h1>
<p>In general, XCM follow the UNIX system API tradition when it comes to error handling. Where possible, errors are signaled to the application by using unused parts of the value range of the function return type. For functions returning signed integer types, this means the value of -1 (in case -1 is not a valid return value). For functions returning pointers, NULL is used to signal that an error has occurred. For functions where neither -1 or NULL can be used, or where the function does not return anything (side-effect only functions), an 'int' is used as the return type, and is used purely for the purpose to signal success (value 0), or an error (-1) to the application.</p>
<p>The actual error code is stored in the thread-local errno variable. The error codes are those from the fixed set of errno values defined by POSIX, found in errno.h. Standard functions such as perror() and strerror() may be used to turn the code into a human-readable string.</p>
<p>In non-blocking operation, given the fact the actual transmission might be defered (and the message buffered in the XCM layer), and that message receive processing might happen before the application has called receive, the error being signaled at the point of a certain XCM call might not be a direct result of the requested operation, but rather an error discovered previously.</p>
<p>The documentation for <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> includes a list of generic error codes, applicable <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<p>Also, for errors resulting in an unusable connection, repeated calls will produce the same errno.</p>
<h1><a class="anchor" id="select"></a>
Event-driven Programming Support</h1>
<p>In UNIX-style event-driven programming, a single application thread handles multiple clients (and thus multiple XCM connection sockets) and the task of accepting new clients on the XCM server socket concurrently (although not in parallel). To wait for events from multiple sources, an I/O multiplexing facility such as select(2) or poll(2) is used.</p>
<p>XCM supports this programming model. However, due to the extensive user space state/buffering required for some XCM transports, and the weak correlation between fd read/write state and actual XCM-level message send/receive that follows, XCM is forced to deviate from the BSD Sockets semantics in this regard.</p>
<h2><a class="anchor" id="select_variants"></a>
Supported I/O Multiplexing Facilities</h2>
<p>XCM allows the application to use select() and poll() by direct calls, or using any of the many event-loop libraries. For simplicity, being the most well-known of options, select() is used in this documentation to denote the whole family of POSIX I/O multiplexing facilities.</p>
<h2><a class="anchor" id="non_blocking_ops"></a>
Non-blocking Operation</h2>
<p>An event-driven application will set the XCM sockets it handles into non-blocking mode (<a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> or the XCM_NONBLOCK flag to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>).</p>
<p>For XCM sockets in non-blocking mode, all potentially blocking API calls related to XCM connections, calls - <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> - finish immediately.</p>
<p>Many such potentially blocking calls will finish immediately and with success. For <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, XCM signaling success means that the XCM layer has accepted the request. It may or may not have completed the request.</p>
<h3><a class="anchor" id="non_blocking_connect"></a>
Non-blocking Connection Establishment</h3>
<p>In case the <a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a> flag is set in the <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> call, or in case the a XCM server socket is in non-blocking mode at the time of a <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> call, the newly created XCM connection returned to the application may be in a semi-operational state, with some internal processing and/or signaling with the remote peer still required before actual message transmission and reception may occur.</p>
<p>The application may attempt to send or receive messages on such semi-operational connections.</p>
<p>There are ways for an application wishing to know when connection establishment or the task of accepting a new client have finished to do so. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for more information.</p>
<h3><a class="anchor" id="non_blocking_send_receive"></a>
Non-blocking Send and Receive</h3>
<p>To receive a message on a XCM connection socket in non-blocking mode, the application may wait for the right conditions to arise, by means of calling <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> with the <a class="el" href="xcm_8h.html#aa3429d5eebf90c5572549d77a3d08f2f">XCM_SO_RECEIVABLE</a> flag set. When select() signals that these conditions are true, the application should issue <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> to attempt to retrieve a message.</p>
<p><a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> may also called on speculation, prior to any <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> call, to poll the socket for incoming messages.</p>
<p>A XCM connection socket may buffer a number of messages, and thus the application should, for optimal performance, repeat <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> until it returns an error, and errno is set to EAGAIN. However, an application may choose to call <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> with <a class="el" href="xcm_8h.html#aa3429d5eebf90c5572549d77a3d08f2f">XCM_SO_RECEIVABLE</a> set, but in that case, if there are buffered messages, the <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> call will return 0, signaling that the socket doesn't have to do anything in order for the application to receive a message.</p>
<p>Similar to receiving a message, an application may use <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> to wait for the right conditions to occur to allow the transmission of a message. Just like with <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>, it may also choose to issue a <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> call on speculation, falling back to <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> and select() only in the face of XCM being unable to accept a new message. XCM will signal that this is the case by having <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> returning an error with errno to EAGAIN.</p>
<p>For send operations on non-blocking connection sockets, XCM may buffer whole or part of the message before transmission to the lower layer. This may be due to socket output buffer underrun, or the need for some in-band signaling, like security keys exchange, to happen before the transmission of the complete message may finish. The XCM layer will (re-)attempt to hand the message over to the lower layer at a future call to <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, or <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<p>An application should never attempt to draw any conclusions directly based the state of the fd or fds used by the XCM socket. The fds may be readable, and yet there may be no message to read from XCM, or it may not be readable, but yet there might be one or several messages buffered in the XCM layer. The same lack of correlation holds true also for <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and the fd writable/non-writable fd state. In addition, XCM may also used file descriptor for other purposes.</p>
<p>For applications wishing to know when any outstanding message transmission has finished, it may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so. Normally, applications aren't expected to require this kind of control. Please also not that the fact a message has left the XCM layer doesn't necessarily mean it has successfully been delivered to the recipient.</p>
<h3><a class="anchor" id="outstanding_tasks"></a>
Finishing Outstanding Tasks</h3>
<p><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> may all leave the connection in a state where work is initiated, but not completed. In addition, the transport may also busy with an internal tasks, such filling its internal buffer with incoming messages, being involved in a key exchange operation (TLS hand shake) or keep alive message transmission or reception.</p>
<p>Prior to the select() call, the application must query any XCM connection or server socket it has in non-blocking mode, asking it what events it is waiting for, and on what file descriptor. This is true even if the application neither wants to send or receive (on a connection socket), or accept incoming connections (on a server socket).</p>
<p>The file descriptor, and the type of event, may change if the application issues any xcm_* calls on that connection. Easiest for the application is likely to query the connection socket immediately prior to each and every select() call.</p>
<p>After waking up from a select() call, where the conditions required by a non-blocking XCM socket are met, the application must, if no <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> calls are to be made, call <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>. This is to allow the socket to finish any outstanding tasks, even in the face of an application having no immediate further use of the socket.</p>
<p>The query is made with <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a>, and it returns an array of file descriptors and, for each fd, the event type(s) the socket is interested in for that fd.</p>
<p>In case the XCM socket has any such needs, the application should wait until the conditions are met (by means of select()). Upon the conditions are met, the application may continue to use the socket.</p>
<p>Prior to changing a socket from non-blocking to blocking mode, any outstanding tasks must be finished.</p>
<h2><a class="anchor" id="might_block"></a>
Ready Status Semantics</h2>
<p>There might be situations that the fd or the fds tied to a XCM connection is marked (by select()) with the appropriate ready status (typically, but not always, write) for a <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> operation to success, but a send may still block (or fail with EAGAIN, if in non-blocking mode). One such may be that the are indeed socket buffer space, but not enough to fit the complete message.</p>
<p>The same situation may arise for <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>. Even though the fd tied to a XCM connection is marked with the appropriate ready status for a message to be received, a <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> may fail, since the complete message has not yet arrived.</p>
<p>Thus, an application may never trust that a <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> or <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> in blocking mode won't block, and similarly may never trust a send or receive operation to never fail and return EAGAIN, regardless of fd status.</p>
<p>See <a class="el" href="index.html#io_waiting">Waiting for Read May Mean Waiting for Write</a> for other reasons that a send or receive may always potentially block.</p>
<h2><a class="anchor" id="io_waiting"></a>
Waiting for Read May Mean Waiting for Write</h2>
<p>XCM is designed to allow transports where all the processing is done in the application's thread of control (i.e. no separate OS threads or processes for a connection to do whatever in-band signaling is required for handling retransmission, dead peer detection, key exchange etc). One transport involving a lot of this kind of processing is the <a class="el" href="index.html#tls_transport">TLS Transport</a>.</p>
<p>For sockets in blocking mode, this complexity is hidden from the application (except in the form of message reception or transmission latency jitter).</p>
<p>For event-driven applications, with their XCM connections in non-blocking mode, this has a non-obvious effect; in order to receive a message, the XCM transport may ask the application to have its thread wait (with select()) for the connection's fd to be marked writable. This is because in order to receive the message, the transport may need to complete some in-band signaling. For example, it may require some new keys for encrypting the outgoing message, since the old have expired.</p>
<p>The other way around may also be true; that in order to write a message, the transport may need to have the application to wait for the fd to become readable (since it needs to receive some signaling message from the remote peer in order to proceed).</p>
<p>The same holds true also for accept operation on server sockets; in order to accept an incoming request, the transport may ask the application to wait for the fd to be come writable.</p>
<h2><a class="anchor" id="nb_examples"></a>
Non-blocking Example Sequences</h2>
<h3><a class="anchor" id="nb_connect_and_send"></a>
Connect and Send Message</h3>
<p>In this example, the application connects and immediately tries to send a message. This may fail (for example, in case TCP and/or TLS-level connection establishement has not yet been completed), in which case the application will fall back and wait with the use of <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> and select().</p>
<div class="plantumlgraph">
<img src="nb_connect_and_send.png" />
</div>
<h3><a class="anchor" id="nb_connect_explicit"></a>
Connect with Explicit Finish</h3>
<p>In case the application wants to know when the connection establishment has finished, it may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so, like in the below example sequence.</p>
<div class="plantumlgraph">
<img src="nb_connect_explicit.png" />
</div>
<h3><a class="anchor" id="nb_immediate_connection_refused"></a>
Immediate Connection Refused</h3>
<p>While connecting to a server socket, the client's connection attempt may be refused immediately.</p>
<div class="plantumlgraph">
<img src="nb_immediate_connection_refused.png" />
</div>
<h3><a class="anchor" id="nb_delayed_connection_refused"></a>
Delayed Connection Refused</h3>
<p>In many cases, the application is handed a connection socket before the connection establishment is completed. Any errors occuring during this process is handed over to the application at the next XCM call; would it be <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> or <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<div class="plantumlgraph">
<img src="nb_delayed_connection_refused.png" />
</div>
<h3><a class="anchor" id="nb_buffering"></a>
Receiving Buffering</h3>
<p>In this example, the application runs into a situation where the operation requested may be perfomed immediately (since XCM already have a buffered message).</p>
<div class="plantumlgraph">
<img src="nb_buffering.png" />
</div>
<h3><a class="anchor" id="nb_flush_buffers_before_close"></a>
Buffer Flush Before Close</h3>
<p>In this example the application flushes any internal XCM buffers before shutting down the connection, to ensure that any buffered messages are delivered to the lower layer.</p>
<div class="plantumlgraph">
<img src="nb_flush_buffers_before_close.png" />
</div>
<h3><a class="anchor" id="nb_server_accept"></a>
Server Accept</h3>
<p>In this sequence, a server accepts a new connection, and continues to attempt to receive a message on this connection, while still, concurrently, is ready to accept more clients on the server socket.</p>
<div class="plantumlgraph">
<img src="server_accept.png" />
</div>
<h1><a class="anchor" id="attributes"></a>
Socket Attributes</h1>
<p>Tied to an XCM server or connection socket is a set of read-only key-value pairs known as attributes. Which attributes are available varies across different transports, and different socket types.</p>
<p>The attribute names are strings, and follows a hierarchical naming schema. For example, all generic XCM attributes, expected to be implemented by all transports, have the prefix "xcm.". Transport-specific attributes are prefixed with the transport or protocol name (e.g. "tcp." for TCP-specific attributes applicable to the TLS and TCP transports).</p>
<p>The attribute value is coded in the native C data types and byte order. Strings are NUL-terminated, and the NUL character is included in the length of the attribute. There are three value types; a boolean type, a 64-bit signed integer type and a string type. See <a class="el" href="xcm__attr__types_8h.html" title="This file contains type definitions for the XCM attribute access API.">xcm_attr_types.h</a> for details.</p>
<p>The attribute access API is in <a class="el" href="xcm__attr_8h.html" title="This file contains the XCM attribute access API. See Socket Attributes for an overview.">xcm_attr.h</a>.</p>
<p>Retrieving an integer attribute may look like this (minus error handling): </p><div class="fragment"><div class="line">int64_t rtt;</div>
<div class="line"><a class="code hl_function" href="xcm__attr_8h.html#accaa82dfb750ba09b9d999a8ce59d95f">xcm_attr_get</a>(tcp_conn_socket, <span class="stringliteral">&quot;tcp.rtt&quot;</span>, NULL, &amp;rtt, <span class="keyword">sizeof</span>(rtt));</div>
<div class="line">printf(<span class="stringliteral">&quot;Current TCP round-trip time estimate is %ld us.&quot;</span>, rtt);</div>
<div class="ttc" id="axcm__attr_8h_html_accaa82dfb750ba09b9d999a8ce59d95f"><div class="ttname"><a href="xcm__attr_8h.html#accaa82dfb750ba09b9d999a8ce59d95f">xcm_attr_get</a></div><div class="ttdeci">int xcm_attr_get(struct xcm_socket *socket, const char *name, enum xcm_attr_type *type, void *value, size_t capacity)</div></div>
</div><!-- fragment --><p>Process-wide and/or read/write attributes may be supported in the future.</p>
<h2><a class="anchor" id="xcm_attr"></a>
Generic Attributes</h2>
<p>These attributes are expected to be found on XCM sockets regardless of transport type.</p>
<p>For TCP transport-specific attributes, see <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a>, and for TLS, see <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.type   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">The socket type - "server" or "connection".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.transport   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">The transport type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.local_addr   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">See <a class="el" href="xcm_8h.html#a7fefa1353b41c2445e13603e80f56336">xcm_local_addr()</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.remote_addr   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">See <a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr()</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.max_msg_size   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The maximum size of any message transported by this connection.   </td></tr>
</table>
<h3><a class="anchor" id="cnt_attr"></a>
Generic Message Counter Attributes</h3>
<p>XCM has a set of generic message counters, which keeps track of the number of messages crossing a certain boundary for a particular connection, and a sum of their size.</p>
<p>Some of the message and byte counter attributes use the concept of a "lower layer". What this means depends on the transport. For the UX And TCP transports, it is the Linux kernel. For example, for TCP, if the xcm.to_lower_msgs is incremented, it means that XCM has successfully sent the complete message to the kernel's networking stack for further processing. It does not means it has reached the receiving process. It may have, but it also may be sitting on the local or remote socket buffer, on a NIC queue, or be in-transmit in the network. For TLS, the lower layer is OpenSSL.</p>
<p>All the "xcm.*_bytes" counters count the length of the XCM message payload (as in the length field in <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>), and thus does not include any underlying headers.</p>
<p>The message counters only count messages succesfully sent and/or received.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_app_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">Messages sent from the application and accepted into XCM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.from_app_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The sum of the size of all messages counted by xcm.from_app_msgs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.to_app_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">Messages delivered from XCM to the application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_app_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The sum of the size of all messages counter by xcm.to_app_msgs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_lower_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">Messages received by XCM from the lower layer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.from_lower_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The sum of the size of all messages counted by xcm.from_lower_msgs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.to_lower_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">Messages successfully sent by XCM into the lower layer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_lower_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The sum of the size of all messages counted by xcm.to_lower_msgs.   </td></tr>
</table>
<h1><a class="anchor" id="ctl"></a>
Control Interface</h1>
<p>XCM includes a control interface, which allows iteration over the OS instance's XCM server and connection sockets (for processes with the appropriate permissions), and access to their attributes (see <a class="el" href="index.html#attributes">Socket Attributes</a>).</p>
<p>The control interface is optional by means of build-time configuration.</p>
<p>For each XCM server or connection socket, there is a corresponding UNIX domain socket which is used for control signaling (i.e. state retrieval).</p>
<h2><a class="anchor" id="ctl_dir"></a>
Control UNIX Socket Directory</h2>
<p>By default, the control interface's UNIX domain sockets are stored in the <code>/run/xcm/ctl</code> directory.</p>
<p>This directory needs to be created prior to running any XCM applications (for the control interface to worker properly) and should be writable for all XCM users.</p>
<p>A particular process using XCM may be configured to use a non-default directory for storing the UNIX domain sockets used for the control interface by means of setting the <code>XCM_CTL</code> variable. Please note that using this setting will cause the XCM connections to be not visible globally on the OS instance (unless all other XCM-using processes also are using this non-default directory).</p>
<h2><a class="anchor" id="ctl_fds"></a>
Additional File Descriptors</h2>
<p>The XCM socket state the control interface allows access to (i.e. the attributes) is owned by the various processes is the system using the XCM library. Thus, to avoid synchronization issues, the control interface is driven by the application's thread(s), although the application is kept unaware of this fact.</p>
<p>If the control interface is enabled, some of the file descriptors returned to the application (in <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a>) will are not tied to the data interface (i.e. <a class="el" href="xcm_8h.html" title="This file contains the core Extensible Connection-oriented Messaging (XCM) API.">xcm.h</a> and the messaging I/O), but rather the control interface.</p>
<p>The control interface is using one file descriptor for the a UNIX domain server socket, and zero or more fds for any control interface clients attached.</p>
<h2><a class="anchor" id="ctl_errors"></a>
Control Interface Error Handling</h2>
<p>Generally, since the application is left unaware (from an API perspective) from the existence of the control interface, errors are not reported up to the application. They are however logged.</p>
<p>Application threads owning XCM sockets, but which are busy with non-XCM processing for a long duration of time, or otherwise are leaving their XCM sockets unattended to (in violation of XCM API contract), will not respond on the control interface's UNIX domain sockets (corresponding to their XCM sockets). Only the prescence of these sockets may be detected, but their state cannot be retrieved.</p>
<h2><a class="anchor" id="ctl_api"></a>
Control API</h2>
<p>Internally, the XCM implementation has control interface client library, but this library's API is not public at this point.</p>
<h2><a class="anchor" id="ctl_shell"></a>
Command-line Control Program</h2>
<p>XCM includes a command-line program <code>xcmctl</code> which uses the <a class="el" href="index.html#ctl_api">Control API</a> to iterate of the system's current XCM sockets, and allow access (primarily for debugging purposes) to the sockets' attributes.</p>
<h1><a class="anchor" id="thread_safety"></a>
Thread Safety</h1>
<p>Unlike BSD sockets, a XCM socket may not be shared among different threads without synchronization external to XCM. With proper external serialization, a socket may be shared by different threads in the same process, although it might provide difficult in practice since a thread in a blocking XCM function will continue to hold the lock, and thus preventing other threads from accessing the socket at all. For non-blocking sockets, the contract of <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> may be broken in so far the conditions on which a thread is waiting for may be change, if another thread calls into that connection socket.</p>
<p>It is however safe to "give away" a XCM socket from one thread to another, provided the appropriate memory fences are used.</p>
<p>These limitations (compared to BSD Sockets) are in place to allow socket state outside the kernel (which is required for TCP framing and TLS).</p>
<h1><a class="anchor" id="fork"></a>
Multi-processing and Fork</h1>
<p>Sharing a XCM socket between threads in different processes is not possible.</p>
<p>After a fork() call, either of the two process (the parent, or the child) must be designated the owner of every XCM socket the parent owned.</p>
<p>The owner may continue to use the XCM socket normally.</p>
<p>The non-owner may not call any other XCM API call than <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a>, which frees local memory tied to this socket in the non-owner's process address space, without impacting the connection state in the owner process.</p>
<h1><a class="anchor" id="transports"></a>
Transports</h1>
<p>The core XCM API functions are oblivious to the transports used. However, the support for building, and parsing addresses (which some applications are expected to do) are available only for a set of pre-defined set of transports. There is nothing preventing <a class="el" href="xcm__addr_8h.html" title="This is an API for building and parsing Connection-oriented Messaging (XCM) addresses.">xcm_addr.h</a> from being extended, and also nothing prevents an alternative XCM implementation to include more transports without touching the address helper API.</p>
<h2><a class="anchor" id="ux_transport"></a>
UX Transport</h2>
<p>The UX transport uses UNIX Domain (AF_UNIX, also known as AF_LOCAL) Sockets.</p>
<p>UX sockets may only be used with the same OS instance (or, more specifically, between processes in the same Linux kernel network namespace).</p>
<p>UNIX Domain Sockets comes in a number of flavors, and XCM uses the SOCK_SEQPACKET variety. SOCK_SEQPACKET sockets are connection-oriented, preserves message boundaries and delivers messages in the same order they were sent; perfectly matching XCM semantics and provides for an near-trivial mapping.</p>
<p>UX is the most efficient of the XCM transports.</p>
<h3><a class="anchor" id="ux_naming"></a>
UX Namespace</h3>
<p>The standard UNIX Domain Sockets as defined by POSIX uses the file system as its namespace, with the sockets also being files. However, for simplicity and to avoid situations where stale socket files (originating from crashed processes) causing problems, the UX transport uses a Linux-specific extension, allowing a private UNIX Domain Socket namespace. This is known as the abstract namespace (see the unix(7) man page for details). With the abstract namespace, server socket address allocation has the same life time as TCP ports (i.e. if the process dies, the address is free'd).</p>
<p>The UX transport enables the SO_PASSCRED BSD socket option, to give the remote peer a name (which UNIX domain connection socket doesn't have by default). This is for debugging and observability purposes. Without a remote peer name, in server processes with multiple incoming connections to the same server socket, it's difficult to say which of the server-side connection sockets goes to which remote peer. The kernel-generated, unique, name is an integer in the form "%05x" (printf format). Applications using hardcoded UX addresses should avoid such names by, for example, using a prefix.</p>
<p>The <a class="el" href="index.html#utls_transport">UTLS Transport</a> also indirectly uses the UX namespace, so care should be taken to avoid any clashes between UX and UTLS sockets in the same network namespace.</p>
<h2><a class="anchor" id="uxf_transport"></a>
UXF Transport</h2>
<p>The UXF transport is identical to the UX transport, only it uses the standard POSIX naming mechanism. The name of a server socket is a file system path, and the socket is also a file.</p>
<p>The UXF sockets resides in a file system namespace, as opposed to UX sockets, which live in a network namespace.</p>
<p>Upon <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a>, the socket will be closed and the file removed. If an application crashes or otherwise fails to run <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a>, it will leave a file in the file system pointing toward a non-existing socket. This file will prevent the creation another server socket with the same name.</p>
<h2><a class="anchor" id="tcp_transport"></a>
TCP Transport</h2>
<p>The TCP transport uses the Transmission Control Protocol (TCP), by means of the BSD Sockets API.</p>
<p>TCP is a byte-stream service, but the XCM TCP transport adds framing on top of the stream. A single-field 32-bit header containing the message length in network byte order is added to every message.</p>
<p>TCP uses TCP Keepalive to detect lost network connectivity between the peers.</p>
<p>The TCP transport supports IPv4 and IPv6.</p>
<p>Since XCM is designed for signaling traffic, the TCP transport disables the Nagle algorithm of TCP to avoid its excessive latency.</p>
<h3><a class="anchor" id="tcp_attr"></a>
TCP Socket Attributes</h3>
<p>The TCP attributes are retrieved from the kernel (struct tcp_info in linux/tcp.h). See the tcp(7) manual page, and its section on the TCP_INFO socket option.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.rtt   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The current TCP round-trip estimate (in us).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.total_retrans   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The total number of retransmitted TCP segments.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.segs_in   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The total number of segments received.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.segs_out   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">The total number of segments sent.   </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd><code>tcp.segs_in</code> and <code>tcp.segs_out</code> are only present when running XCM on Linux kernel 4.2 or later.</dd></dl>
<h2><a class="anchor" id="tls_transport"></a>
TLS Transport</h2>
<p>The TLS transport uses TLS to provide a secure, private, two-way authenticated transport.</p>
<p>TLS is a byte-stream service, but the XCM TLS transport adds framing in the same manner as does the XCM TCP transport.</p>
<p>The TLS transport supports IPv4 and IPv6.</p>
<p>The TLS transport disables the Nagle algorithm of TCP.</p>
<h3><a class="anchor" id="tls_certificates"></a>
TLS Certificate and Key Storage</h3>
<p>The TLS transport expect the certificate, trust chain and private key files to be found in a file system directory - the certificate directory. The default path are configured at build-time, but can be overriden on a per-process basis by means of a UNIX environment variable. The current value of <code>XCM_TLS_CERT</code> (at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>) determines the certificate directory used for that connection.</p>
<p>In case the files in the certificate directory are modified, the new versions of the files will be used by new connections. The TLS transports works with differences between set of files, and thus the new generation of files need not nesserarily be newer (i.e. higher mtime).</p>
<p>The certificate directory must be updated in an atomic manner, or XCM may end up using the certificate file from one generation of files and the key file from another. One way of achieving an atomic update is to have the certificate directory being a symbolic link to the directory where the actual files are located. Upon update, a new directory is created and populated, and the old symbolic link is replace with a new one in an atomic manner (i.e. with rename(2)). It's legal to switch back-and-forth between two sets of files, but the time between the back and the forth switch (assuming the atomicity-by-symlink method is used) must be enough to result in different file system modification times on the symbolic link (usually ~10 ms).</p>
<p>The TLS transport will, at the time of XCM socket creation (<a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> or <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>), look up the process' current network namespace. In case the namespace is given a name per the iproute2 methods and conventions, XCM will retrieve this name and use it in the certificate and key lookup.</p>
<p>In the certificate directory, the TLS transport expects the certificate to follow the below naming convention (where &lt;ns&gt; is the namespace): </p><div class="fragment"><div class="line">cert_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The private key is stored in: </p><div class="fragment"><div class="line">key_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The trust chain is stored in: </p><div class="fragment"><div class="line">tc_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>For the default namespace (or any other network namespace not named according to iproute2 standards), the certificate need to be stored in a file "cert.pem", the private key in "key.pem" and the trust chain in "tc.pem".</p>
<p>In case the certificate, key or trust chain files are not in place (for a particular namespace), a <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> call will return an error and set errno to EPROTO. The application may choose to retry at a later time.</p>
<h3><a class="anchor" id="tls_attr"></a>
TLS Socket Attributes</h3>
<p>TLS has all the TCP-level attributes of the TCP transport; see <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.peer_subject_key_id   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">The X509v3 Subject Key Identifier of the remote peer, or a zero-length string in case the TLS connection is not established.   </td></tr>
</table>
<h2><a class="anchor" id="utls_transport"></a>
UTLS Transport</h2>
<p>The UTLS transport provides a hybrid transport, utilizing both the TLS and UX transports internally for actual connection establishment and message delivery.</p>
<p>On the client side, at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, the UTLS transport determines if the server socket can be reached by using the UX transport (i.e. if the server socket is located on the same OS instance, in the same network namespace). If not, UTLS will attempt to reach the server by means of the TLS transport.</p>
<p>For a particular UTLS connection, either TLS or UX is used (never both). XCM connections to a particular UTLS server socket may be a mix of the two different types.</p>
<p>In the UTLS transport, <a class="el" href="xcm_8h.html#a2e09a4b8705bb688ffe57f184308186e">xcm_want()</a> will return at least two file descriptors; one for the TCP BSD socket file descriptor utilized for TLS, and one for the UNIX domain socket. However, the applications should not depend on this (or the fact that other transports might return fewer).</p>
<p>For an UTLS server socket with the address <code>utls:&lt;ip&gt;:&lt;port&gt;</code>, two underlying addresses will be allocated; <code>tls:&lt;ip&gt;:&lt;port&gt;</code> and <code>ux:&lt;ip&gt;:&lt;port&gt;</code>.</p>
<p>Or, in the case DNS is used: <code>tls:&lt;hostname&gt;:&lt;port&gt;</code> and <code>ux:&lt;hostname&gt;:&lt;port&gt;</code>.</p>
<h3><a class="anchor" id="utls_limitations"></a>
UTLS Limitations</h3>
<p>A wildcard should never be used when creating a UTLS server socket.</p>
<p>If a DNS hostname is used in place of the IP address, both the client and server need employ DNS, and also agree upon which hostname to use (in case there are several pointing at the same IP address).</p>
<p>Failure to adhere to the above two rules will prevent a client from finding a local server. Such a client will instead establish a TLS connection to the server.</p>
<h2><a class="anchor" id="sctp_transport"></a>
SCTP Transport</h2>
<p>The SCTP transport uses the Stream Control Transmission Protocol (SCTP). SCTP provides a reliable, message-oriented service. In-order delivery is optional, and to adhere to XCM semantics (and for other reasons) XCM leaves SCTP in-order delivery enabled.</p>
<p>The SCTP transport utilizes the native Linux kernel's implementation of SCTP, via the BSD Socket API. The operating mode is such that there is a 1:1-mapping between an association and a socket (fd).</p>
<p>The SCTP transport supports IPv4 and IPv6.</p>
<p>To minimize latency, the SCTP transport disables the Nagle algorithm.</p>
<h1><a class="anchor" id="namespaces"></a>
Linux Network and IPC Namespaces</h1>
<p>Namespaces is a Linux kernel facility concept for creating multiple, independent namespaces for kernel resources of a certain kind.</p>
<p>Linux Network Namespaces will affect all transports, including the UX transport.</p>
<p>XCM has no explicit namespace support, but the application is rather expected to use the Linux kernel facilities for this functionality (i.e. switch to the right namespace before <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> och <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>).</p>
<p>In case the system follows the iproute2 conventions in regards to network namespace naming, the TLS and UTLS transports support per-network namespace TLS certificates and private keys.</p>
<h1><a class="anchor" id="limitations"></a>
Limitations</h1>
<p>XCM, in its current form, does not support binding to a local socket before doing connect() - something that is possible with BSD Sockets, but very rarely makes sense.</p>
<p>XCM also doesn't have a sendmmsg() or recvmmsg() equivalent. Those could easily be added, and would provide some major performance improvements for applications that are sending or receiving multiple messages on the same connection on the same time. *mmsg() equivalents have been left out because there are strong doubts there are such applications. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 30 2025 11:12:41 for Extensible Connection-oriented Messaging (XCM) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
