<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extensible Connection-oriented Messaging (XCM): Extensible Connection-oriented Messaging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extensible Connection-oriented Messaging (XCM)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Extensible Connection-oriented Messaging </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#semantics">Overall Semantics</a><ul><li class="level2"><a href="#service_types">Messaging and Byte Streams</a><ul><li class="level3"><a href="#max_msg_size">Max Message Size</a></li>
</ul>
</li>
<li class="level2"><a href="#ordering">Ordering Guarantees</a></li>
<li class="level2"><a href="#flow_control">Flow Control</a></li>
</ul>
</li>
<li class="level1"><a href="#addressing">Addressing and Transport Selection</a><ul><li class="level2"><a href="#address_syntax">Address Syntax</a><ul><li class="level3"><a href="#dns">DNS Resolution</a></li>
<li class="level3"><a href="#ip_addr_format">IPv4 Address Format</a></li>
<li class="level3"><a href="#scope">IPv6 Link Local Addresses</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#dpd">Dead Peer Detection</a></li>
<li class="level1"><a href="#error_handling">Error Handling</a></li>
<li class="level1"><a href="#select">Event-driven Programming Support</a><ul><li class="level2"><a href="#select_variants">Supported I/O Multiplexing Facilities</a></li>
<li class="level2"><a href="#non_blocking_ops">Non-blocking Operation</a><ul><li class="level3"><a href="#non_blocking_connect">Non-blocking Connection Establishment</a></li>
<li class="level3"><a href="#non_blocking_send_receive">Non-blocking Send and Receive</a></li>
<li class="level3"><a href="#outstanding_tasks">Finishing Outstanding Tasks</a></li>
</ul>
</li>
<li class="level2"><a href="#might_block">Ready Status Semantics</a></li>
<li class="level2"><a href="#nb_examples">Non-blocking Example Sequences</a><ul><li class="level3"><a href="#nb_connect_and_send">Connect and Send Message</a></li>
<li class="level3"><a href="#nb_connect_explicit">Connect with Explicit Finish</a></li>
<li class="level3"><a href="#nb_immediate_connection_refused">Immediate Connection Refused</a></li>
<li class="level3"><a href="#nb_delayed_connection_refused">Delayed Connection Refused</a></li>
<li class="level3"><a href="#nb_flush_buffers_before_close">Buffer Flush Before Close</a></li>
<li class="level3"><a href="#nb_server_accept">Server Accept</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#attributes">Socket Attributes</a><ul><li class="level2"><a href="#attribute_names">Attribute Names</a></li>
<li class="level2"><a href="#attribute_values">Attribute Values</a></li>
<li class="level2"><a href="#attribute_structure">Basic Structure</a></li>
<li class="level2"><a href="#attribute_access">Attribute Access</a></li>
<li class="level2"><a href="#attr_bulk">Socket Instantiation Configuration</a></li>
<li class="level2"><a href="#xcm_attr_inheritance">Attribute Inheritance</a></li>
<li class="level2"><a href="#xcm_attr">Generic Attributes</a><ul><li class="level3"><a href="#cnt_attr">Generic Counter Attributes</a><ul><li class="level4"><a href="#common_cnt_attr">Byte Counter Attributes</a></li>
<li class="level4"><a href="#messaging_cnt_attr">Message Counter Attributes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#ctl">Control Interface</a><ul><li class="level2"><a href="#ctl_dir">Control UNIX Socket Directory</a></li>
<li class="level2"><a href="#ctl_errors">Control Interface Error Handling</a></li>
<li class="level2"><a href="#ctl_api">Control API</a></li>
<li class="level2"><a href="#ctl_shell">Command-line Control Program</a></li>
</ul>
</li>
<li class="level1"><a href="#thread_safety">Thread Safety</a></li>
<li class="level1"><a href="#fork">Multi-processing and Fork</a></li>
<li class="level1"><a href="#transports">Transports</a><ul><li class="level2"><a href="#ux_transport">UX Transport</a><ul><li class="level3"><a href="#ux_naming">UX Namespace</a></li>
</ul>
</li>
<li class="level2"><a href="#uxf_transport">UXF Transport</a></li>
<li class="level2"><a href="#tcp_transport">TCP Transport</a><ul><li class="level3"><a href="#dns_attr">DNS Socket Attributes</a><ul><li class="level4"><a href="#dns_algorithm_attr">DNS Resolution and TCP Connection Establishment</a></li>
</ul>
</li>
<li class="level3"><a href="#tcp_attr">TCP Socket Attributes</a></li>
</ul>
</li>
<li class="level2"><a href="#tls_transport">TLS Transport</a><ul><li class="level3"><a href="#tls_version">TLS Protocol Version and Features</a></li>
<li class="level3"><a href="#tls_ciphers">Cipher Suites</a></li>
<li class="level3"><a href="#tls_groups">Groups</a></li>
<li class="level3"><a href="#tls_certificates">Certificate and Key Handling</a><ul><li class="level4"><a href="#credentials_format">Certificate and Key Format</a></li>
<li class="level4"><a href="#per_ns_certs">Per-network Namespace Certificates</a></li>
<li class="level4"><a href="#default_certs">Default Namespace Certificates</a></li>
<li class="level4"><a href="#cert_update">Runtime Certificate File Updates</a></li>
</ul>
</li>
<li class="level3"><a href="#tls_role">Role Configuration</a></li>
<li class="level3"><a href="#tls_auth">Authentication</a></li>
<li class="level3"><a href="#name_verification">X.509v3 Subject Name Verification</a></li>
<li class="level3"><a href="#crl_checks">Certification Revocation List Checks</a></li>
<li class="level3"><a href="#validity_checks">Certificate Validity Period Checks</a></li>
<li class="level3"><a href="#tls_attr">TLS Socket Attributes</a></li>
</ul>
</li>
<li class="level2"><a href="#utls_transport">UTLS Transport</a><ul><li class="level3"><a href="#utls_attr">UTLS Socket Attributes</a></li>
<li class="level3"><a href="#utls_limitations">UTLS Limitations</a></li>
</ul>
</li>
<li class="level2"><a href="#sctp_transport">SCTP Transport</a></li>
<li class="level2"><a href="#btcp_transport">BTCP Transport</a></li>
<li class="level2"><a href="#btls_transport">BTLS Transport</a></li>
</ul>
</li>
<li class="level1"><a href="#namespaces">Linux Network and IPC Namespaces</a></li>
<li class="level1"><a href="#tracing">Tracing</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>This is the API documentation for the Extensible Connection-oriented Messaging (XCM) library.</p>
<p>The XCM API consists of the following parts:</p><ul>
<li>Core API: <a class="el" href="xcm_8h.html" title="Core XCM API.">xcm.h</a>.</li>
<li>Address handling library: <a class="el" href="xcm__addr_8h.html" title="API for parsing and building XCM addresses.">xcm_addr.h</a>.</li>
<li>Socket attribute APIs: <a class="el" href="xcm__attr_8h.html" title="XCM socket attribute access API.">xcm_attr.h</a> and <a class="el" href="xcm__attr__map_8h.html" title="XCM attribute map API.">xcm_attr_map.h</a>.</li>
<li>API and implementation version information: <a class="el" href="xcm__version_8h.html" title="Functions and macros to retrieve XCM versioning information.">xcm_version.h</a>.</li>
<li>Obsolete (but still available) APIs: <a class="el" href="xcm__compat_8h.html" title="Obsolete parts of the XCM API.">xcm_compat.h</a>.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Mattias RÃ¶nnblom </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.27 [API] </dd>
<dd>
1.12.0 [Implementation]</dd></dl>
<p>The low API/ABI version number is a result of all XCM releases being backward compatible, and thus left the major version at 0.</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>XCM is a shared library implementing an inter-process communication service on Linux. It facilitates communication between processes on the same system, as well as over a network.</p>
<p>XCM internals are divided into the core library, and a number of pluggable transports, handling the actual data delivery. In combination with an URL-like addressing scheme, it allows applications to be transport agnostic, and an IPC mechanism suitable for one deployment can seamlessly be replaced with another, in another deployment. The API semantics are the same, regardless of underlying transport used.</p>
<p>An XCM transport either provides a messaging or a byte stream type service.</p>
<p>XCM supports UNIX domain sockets for efficient local-only communication, and TCP, TLS and SCTP for remote inter-process communication. The service XCM provides is of the connection-oriented, client-server type. It is not a message bus and does not implement the publish-subscribe or broadcast patterns.</p>
<p>This document primarily serves as an API specification, but also also contains information specific to the implementation.</p>
<p>XCM reuses much of the terminology of the BSD Sockets API. Compared to the BSD Sockets API, XCM has more uniform semantics across underlying transports.</p>
<h1><a class="anchor" id="semantics"></a>
Overall Semantics</h1>
<p>XCM implements a connection-oriented, client-server model. The server process creates one or more server sockets (e.g, with <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>) bound to a specific address, after which clients may successfully establish connections to the server. When a connection is establishment, two connection sockets will be created; one on the server side (e.g., returned from <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>), and one of the client side (e.g., returned from <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>). Thus, a server serving multiple clients will have multiple sockets; one server socket and N connection sockets, one each for every client. A client will typically have one connection socket for each server it is connected to.</p>
<p>User application data (messages or bytes, depending on service type) are always sent and received on a particular connection socket - never on a server socket.</p>
<h2><a class="anchor" id="service_types"></a>
Messaging and Byte Streams</h2>
<p>An XCM transport either provides a messaging or a byte stream service.</p>
<p>Messaging transports preserve message boundaries across the network. The buffer passed to <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> constitutes one (and only one) message. What's received on the other end, in exactly one <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> call, is a buffer with the same length and contents.</p>
<p>The <a class="el" href="index.html#ux_transport">UX Transport</a>, <a class="el" href="index.html#tcp_transport">TCP Transport</a>, <a class="el" href="index.html#tls_transport">TLS Transport</a>, <a class="el" href="index.html#utls_transport">UTLS Transport</a>, and <a class="el" href="index.html#sctp_transport">SCTP Transport</a> all provide a messaging type service.</p>
<p>For byte streams, there's no such thing as message boundaries: the data transported on the connection is just a sequence of bytes. The fact that <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> accepts an array of bytes of a particular length, as opposed to individual bytes one-by-one, is a mere performance optimization.</p>
<p>For example, if two messages "abc" and "d" are passed to <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> on to a messaging transport, they will arrive as "abc" and "d" in exactly two <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> call on the receiver. On a byte stream transport however, all the data "abcd" may arrive in a single <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>, or it may arrive in multiple calls, such as three calls, each producing "ab", "c", and "d", respectively, or any other combination.</p>
<p>The <a class="el" href="index.html#btls_transport">BTLS Transport</a> and <a class="el" href="index.html#btcp_transport">BTCP Transport</a> transports provide a byte stream service.</p>
<p>Applications that allow the user to configure an arbitrary XCM address, but are designed to handle only a certain service type, may limit what type of sockets may be instantiated to be of only the messaging service type, or only byte stream, by passing the "xcm.service" attribute with the appropriate value (see <a class="el" href="index.html#xcm_attr">Generic Attributes</a> for details) at the time of socket creation. Because of XCM's history as a messaging-only framework, "xcm.service" defaults to "messaging".</p>
<p>Applications which are designed to handle both messaging and byte stream transports may retrieve the value of "xcm.service" and use it to differentiate the treatment where so is required (e.g., in <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> return code handling).</p>
<p>Connections spawned off a server socket (e.g., with <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>) always have the same service type as their parent socket.</p>
<h3><a class="anchor" id="max_msg_size"></a>
Max Message Size</h3>
<p>The XCM API and the various messaging type transports are designed for relatively small messages. For bulk data transfer, an application needs either employ fragmentation and reassembly, or use a byte stream transport.</p>
<p>The <code>xcm.max_msg_size</code> socket attribute specifies the maximum message size (see <a class="el" href="index.html#xcm_attr">Generic Attributes</a>).</p>
<p>Current XCM transports do not negotiate the maximum message size, so the <code>xcm.max_msg_size</code> limit denotes the <em>local</em> limit only. The remote end will reject messages larger than <em>its</em> limit, and may tear down the connection as a result. Application protocol level signaling or lockstep upgrade may be required to resolve such issues.</p>
<p>Historically, all messaging type transports in XCM have used a maximum message size of 65535 bytes. This limit was never exposed in the API, so subsequent changes to message size limits did not impact the API/ABI.</p>
<p>As of XCM v1.11.1, the maximum message size varies across different transports.</p>
<p>Applications using stack-allocated message buffers may want to impose their own upper limit (e.g., <code>sizeof(msgbuf)</code>) on top of the <code>xcm.max_msg_size</code>, to avoid overrunning the stack if linked to a newer, message size-wise more capable, XCM library version.</p>
<h2><a class="anchor" id="ordering"></a>
Ordering Guarantees</h2>
<p>In-order delivery - that data arrives at the recipient in the same order it was sent by the sender - is guaranteed, but only for data sent on the same connection.</p>
<h2><a class="anchor" id="flow_control"></a>
Flow Control</h2>
<p>XCM transports support flow control. Thus, if the sender message rate or bandwidth is higher than the network or the receiver can handle on a particular connection, <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> in the sender process will eventually block (or return an error EAGAIN, if in non-blocking mode). Unless XCM is used for bulk data transfer (as oppose to signaling traffic), <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> blocking because of slow network or a slow receiver should be rare in practice. TCP, TLS, and UNIX domain socket transports all have large protocol windows and/or socket buffers to allow a large amount of outstanding data.</p>
<h1><a class="anchor" id="addressing"></a>
Addressing and Transport Selection</h1>
<p>In XCM, the application is in control of which transport will be used, using the address supplied to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> including both the transport name and the transport address.</p>
<p>However, there is nothing preventing an XCM transport to use a more abstract addressing format, and internally include multiple underlying IPC transport mechanism. This model is implemented by the <a class="el" href="index.html#utls_transport">UTLS Transport</a>.</p>
<h2><a class="anchor" id="address_syntax"></a>
Address Syntax</h2>
<p>Addresses are represented as strings with the following general syntax: <code>&lt;transport-name&gt;:&lt;transport-address&gt;</code></p>
<p>For the UX UNIX Domain Socket transport, the addresses has this more specific form: <br  />
</p><div class="fragment"><div class="line">ux:&lt;UNIX domain socket name&gt; </div>
</div><!-- fragment --><p>The addresses of the UXF UNIX Domain Socket transport variant have the following format: <br  />
</p><div class="fragment"><div class="line">uxf:&lt;file system path&gt; </div>
</div><!-- fragment --><p>For the TCP, TLS, UTLS, SCTP, BTCP and BTLS transports the syntax is: <br  />
</p><div class="fragment"><div class="line">tcp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">tls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">utls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">sctp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">btcp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">btls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
</div><!-- fragment --><p>'*' is a shorthand for '0.0.0.0' (i.e. bind to all IPv4 interfaces). '[*]' is the IPv6 equivalent, creating a server socket accepting connections on all IPv4 and IPv6 addresses.</p>
<p>Some example addresses: </p><div class="fragment"><div class="line">tcp:*:4711</div>
<div class="line">tls:192.168.1.42:4711</div>
<div class="line">tcp:[::1]:99</div>
<div class="line">tcp:[*]:4711</div>
<div class="line">tls:service:4711</div>
<div class="line">sctp:service.company.com:42</div>
<div class="line">btls:*:42</div>
</div><!-- fragment --><p>For TCP, TLS, UTLS, SCTP, BTLS and BTCP server socket addresses, the port can be set to 0, in which case XCM (or rather, the Linux kernel) allocates a free TCP port from the local port range.</p>
<h3><a class="anchor" id="dns"></a>
DNS Resolution</h3>
<p>For transports allowing a DNS domain name as a part of the address, the transport will attempt to resoÄºv the name to an IP address. A DNS domain name may resolv to zero or more IPv4 addresses and/or zero or more IPv6 addresses. XCM relies on the operating system to prioritize between IPv4 and IPv6.</p>
<p>By default, XCM will only connect to the first (highest-priority) IP address provided by DNS. This behavior can be changed for all TCP-based transports using the "dns.algorithm" attribute. See <a class="el" href="index.html#dns_attr">DNS Socket Attributes</a> for more information.</p>
<h3><a class="anchor" id="ip_addr_format"></a>
IPv4 Address Format</h3>
<p>XCM accepts IPv4 addresses in the dotted-decimal format </p><div class="fragment"><div class="line">130.236.254.2</div>
</div><!-- fragment --><p>XCM allows only complete addresses with three '.', and not the archaic, classful, forms, where some bytes where left out, and thus the address contained fewer separators.</p>
<h3><a class="anchor" id="scope"></a>
IPv6 Link Local Addresses</h3>
<p>IPv6 link local addresses (i.e., fe80::/10) are not guaranteed to be unique outside a particular broadcast domain. To create such a socket an application must, besides the link local address to use, also supply a scope identifier, to allow the kernel to select which network interface to use.</p>
<p>The IPv6 scope id is not a part of an XCM address, but instead provided by the application as a socket attribute "ipv6.scope". See <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a> for details.</p>
<p>The rationale for this URI-style design choice, compared to the also-common practice to include a network interface name in the address ("&lt;IPv6 address&gt;%&lt;if-name&gt;"), is that the IPv6 scope identifiers are strictly local to the node and thus conceptually not a part of the address. One host may use a particular scope id to refer to a particular network, and another host on the same network may use a different.</p>
<h1><a class="anchor" id="dpd"></a>
Dead Peer Detection</h1>
<p>XCM transports attempt to detect a number of conditions which can lead to lost connectivity, and does so even on idle connections.</p>
<p>If the remote end closes the connection, the local <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> will return 0. If the process on the remote end crashed, <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> will return -1 and set errno ECONNRESET. If network connectivity to the remote end is lost, <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> will return -1 and errno will be set to ETIMEDOUT.</p>
<h1><a class="anchor" id="error_handling"></a>
Error Handling</h1>
<p>In general, XCM follows the UNIX system API tradition when it comes to error handling. Where possible, errors are signaled to the application by using unused parts of the value range of the function return type. For functions returning signed integer types, this means the value of -1 (in case -1 is not a valid return value). For functions returning pointers, NULL is used to signal that an error has occurred. For functions where neither -1 or NULL can be used, or where the function does not return anything (side-effect only functions), an 'int' is used as the return type, and is used purely for the purpose to signal success (value 0), or an error (-1) to the application.</p>
<p>The actual error code is stored in the thread-local errno variable. The error codes are those from the fixed set of errno values defined by POSIX, found in errno.h. Standard functions such as perror() and strerror() may be used to turn the code into a human-readable string.</p>
<p>In non-blocking operation, given the fact the actual transmission might be defered (and the message buffered in the XCM layer), and that message receive processing might happen before the application has called receive, the error being signaled at the point of a certain XCM call might not be a direct result of the requested operation, but rather an error discovered previously.</p>
<p>The documentation for <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> includes a list of generic error codes, applicable <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> and <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>.</p>
<p>Also, for errors resulting in an unusable connection, repeated calls will produce the same errno.</p>
<h1><a class="anchor" id="select"></a>
Event-driven Programming Support</h1>
<p>In UNIX-style event-driven programming, a single application thread handles multiple clients (and thus multiple XCM connection sockets) and the task of accepting new clients on the XCM server socket concurrently (although not in parallel). To wait for events from multiple sources, an I/O multiplexing facility such as select(2), poll(2) or epoll(2) is used.</p>
<p>Each XCM socket is represented by a single fd, retrieved with <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a>. The fd number and underlying file object remains the same across the life-time of the socket.</p>
<p>In the BSD Sockets API, the socket fd being readable means it's likely, but not guaranteed, that the application can successfully read data from the socket. Similarly, a fd marked writable by for example poll() signifies that the application is likely to be able to write data to the socket.</p>
<p>An application using non-blocking XCM sockets must <em>always</em> wait for the XCM socket fd to become <em>readable</em> (e.g., the XCM socket fd should always be in the <code>readfds</code> in the select() call), <em>regardless of the target condition</em>. Thus, even if the application is waiting for an opportunity to send a message on a XCM socket, or is not interested in performing any type of operation on the socket, it must wait for the XCM socket fd to become readable. Not being interested in performing any operation here means that the application has the <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> condition set to 0, and is neither interested in waiting to call <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>, <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>, nor <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> on the socket.</p>
<p>An application must always include <em>all</em> of its XCM socket fds into <code>readfds</code> in the select() call. An application must not leave an XCM socket unattended in the sense its fd is not in the set of fds passed to select() and/or neither of <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>, <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> are called when its fd is marked readable by select().</p>
<h2><a class="anchor" id="select_variants"></a>
Supported I/O Multiplexing Facilities</h2>
<p>XCM is oblivious to what I/O multiplexing mechanism employed by the application. It may call select(), poll() or epoll_wait() directly, or make use of any of the many available event loop libraries (such as libevent). For simplicity, select() is used in this documentation to denote the whole family of Linux I/O multiplexing facilities.</p>
<h2><a class="anchor" id="non_blocking_ops"></a>
Non-blocking Operation</h2>
<p>An event-driven application needs to set the XCM sockets it handles into non-blocking mode, by calling <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a>, setting the "xcm.blocking" socket attribute, or using the XCM_NONBLOCK flag in <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>.</p>
<p>For XCM sockets in non-blocking mode, all potentially blocking API calls related to XCM connections - <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>, and <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> - finish immediately.</p>
<p>The inability to finish the requested operation without blocking the thread (i.e., putting the thread to sleep) is signaled in the typical UNIX manner, by returning an NULL or -1, (depending on the return type) and setting errno to EAGAIN. Unlike most other errno values, EAGAIN is a temporary condition, and not a fatal error.</p>
<p>For <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, XCM signaling success means that the XCM layer has accepted the request. It may or may not have completed the operation.</p>
<h3><a class="anchor" id="non_blocking_connect"></a>
Non-blocking Connection Establishment</h3>
<p>In case the <a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a> flag is set in the <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> call, or in case the an XCM server socket is in non-blocking mode at the time of an <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> call, the newly created XCM connection returned to the application may be in a semi-operational state, with some internal processing and/or signaling with the remote peer still required before actual message transmission and reception may occur.</p>
<p>The application may attempt to send or receive messages on such semi-operational connections.</p>
<p>There are ways for an application to determine when connection establishment or the task of accepting a new client have completed. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for more information.</p>
<h3><a class="anchor" id="non_blocking_send_receive"></a>
Non-blocking Send and Receive</h3>
<p>To receive a message on an XCM connection socket in non-blocking mode, the application may need to wait for the right conditions to arise (i.e. a message being available). The application needs to inform the socket that it wants to receive by calling <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> with the <code>XCM_SO_RECEIVABLE</code> bit in the <code>condition</code> bit mask set. It will pass the fd it received from <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> into select(), asking to get notified when the fd becomes readable. When select() marks the socket fd as readable, the application should issue <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> to attempt to retrieve a message.</p>
<p><a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> may also called on speculation, prior to any select() call, to poll the socket for incoming messages.</p>
<p>An XCM connection socket may have a number of messages buffered, and applications should generally, for optimal performance, repeat <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> until it returns an error, and errno is set to EAGAIN.</p>
<p>Similarly to receiving a message, an application may set the <code>XCM_SO_SENDABLE</code> bit in the <code>condition</code> bit mask, if it wants to wait for a socket state where it's likely it can successfully send a message. When select() marks the socket fd as <em>readable</em>, the application should attempt to send a message.</p>
<p>Just like with <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>, it may also choose to issue a <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> call on speculation (i.e. without going into select()), which is often a good idea for performance reasons.</p>
<p>For send operations on non-blocking connection sockets, XCM may buffer whole or part of the message (or data, for byte stream transports) before transmission to the lower layer. This may be due to socket output buffer underrun, or the need for some in-band signaling, like cryptographic key exchange, to happen before the transmission of the complete message may finish. The XCM layer will (re-)attempt to hand the message over to the lower layer at a future call to <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>, or <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>.</p>
<p>For applications wishing to determine when all buffered data have successfully been deliver to the lower layer, may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so. Normally, applications aren't expected to require this kind of control. Please also note that the fact a message has left the XCM layer doesn't necessarily mean it has successfully been delivered to the recipient. In particular, if for some reason the data can be dispatched immediately, it may be lingering in kernel buffers. Such buffers may be discarded in case the application close the connection.</p>
<h3><a class="anchor" id="outstanding_tasks"></a>
Finishing Outstanding Tasks</h3>
<p><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> may all leave the socket in a state where work is initiated, but not completed. In addition, the socket may have pending internal tasks, such flushing the output buffer into the TCP/IP stack, processing XCM control interface messages, or finishing the TLS hand shake procedure.</p>
<p>After waking up from a select() call, where a particular XCM non-blocking socket's fd is marked readable, the application must, if no <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>, <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> calls are to be made, call <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>. This is to allow the socket to finish any outstanding tasks, even in the case the application has no immediate plans for the socket.</p>
<p>Prior to changing a socket from non-blocking to blocking mode, any outstanding tasks should be finished, or otherwise the switch might cause <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> to return -1 and set errno to EAGAIN.</p>
<h2><a class="anchor" id="might_block"></a>
Ready Status Semantics</h2>
<p>For example, if a server socket's desired condition has been set (with <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a>) to <code>XCM_SO_ACCEPTABLE</code>, and the application wakes up from select() with the socket's fd marked readable, a call to <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> may still not produce a new connection socket.</p>
<p>The same holds true when reaching <code>XCM_SO_RECEIVABLE</code> and a <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a> call is made, and <code>XCM_SO_SENDABLE</code> and calls to <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>.</p>
<h2><a class="anchor" id="nb_examples"></a>
Non-blocking Example Sequences</h2>
<h3><a class="anchor" id="nb_connect_and_send"></a>
Connect and Send Message</h3>
<p>In this example, the application connects and tries to send a message, before knowing if the connection is actually established. This may fail (for example, in case TCP and/or TLS-level connection establishment has not yet been completed), in which case the application will fall back and wait with the use of <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a>, <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> and select().</p>
<div class="plantumlgraph">
<img src="nb_connect_and_send.png" />
</div>
<h3><a class="anchor" id="nb_connect_explicit"></a>
Connect with Explicit Finish</h3>
<p>In case the application wants to know when the connection establishment has finished, it may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so, like in the below example sequence.</p>
<div class="plantumlgraph">
<img src="nb_connect_explicit.png" />
</div>
<h3><a class="anchor" id="nb_immediate_connection_refused"></a>
Immediate Connection Refused</h3>
<p>While connecting to a server socket, the client's connection attempt may be refused immediately.</p>
<div class="plantumlgraph">
<img src="nb_immediate_connection_refused.png" />
</div>
<h3><a class="anchor" id="nb_delayed_connection_refused"></a>
Delayed Connection Refused</h3>
<p>In many cases, the application is handed a connection socket before the connection establishment is completed. Any errors occuring during this process is handed over to the application at a future call to <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a> or <a class="el" href="xcm_8h.html#a58463793b550c16e021efe04b0d743ae">xcm_receive()</a>.</p>
<div class="plantumlgraph">
<img src="nb_delayed_connection_refused.png" />
</div>
<h3><a class="anchor" id="nb_flush_buffers_before_close"></a>
Buffer Flush Before Close</h3>
<p>In this example the application flushes any internal XCM buffers before shutting down the connection, to ensure that any buffered messages are delivered to the lower layer.</p>
<div class="plantumlgraph">
<img src="nb_flush_buffers_before_close.png" />
</div>
<h3><a class="anchor" id="nb_server_accept"></a>
Server Accept</h3>
<p>In this sequence, a server accepts a new connection, and continues to attempt to receive a message on this connection, while still, concurrently, is ready to accept more clients on the server socket.</p>
<div class="plantumlgraph">
<img src="server_accept.png" />
</div>
<h1><a class="anchor" id="attributes"></a>
Socket Attributes</h1>
<p>Associated to a XCM server or connection socket is a set of XCM socket attributes.</p>
<p>Socket attributes represent both read-only state (e.g., TCP round-trip time), and read-write run-time configuration (e.g., TCP keepalive configuration).</p>
<p>Which attributes are present varies across different transports, socket types (i.e., server or connection) and socket states (i.e., fully established or not).</p>
<p>The socket attribute API &lt;<a class="el" href="xcm__attr_8h.html" title="XCM socket attribute access API.">xcm_attr.h</a>&gt; provides access to transport-specific parameters, without the need to extend the API with transport-specific function calls.</p>
<p>Socket attributes are organized as a tree. An attribute's name is a string which describes a path to a node in the tree. The leaf nodes are one of a number of primitive types, such as integers and strings (see &lt;<a class="el" href="xcm__attr__types_8h.html" title="XCM attribute value type definitions.">xcm_attr_types.h</a>&gt; for the full list). Composite (interior) nodes are either dictionaries or lists.</p>
<p>An attribute may be read-only, write-only or available both for reading and writing. This is referred to as the attribute's mode. The mode may vary across the lifetime of the socket. For example, an attribute may be writable at the time of the <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call, and read-only thereafter.</p>
<h2><a class="anchor" id="attribute_names"></a>
Attribute Names</h2>
<p>An attribute name (or, path name) is a string consisting of a sequence of dictionary keys and list indices. Keys are separated by a colon ".", and indices are enclosed in square brackes "[&lt;index&gt;]".</p>
<p>Read from the left, each segment in the path moves one level away from the root.</p>
<p>Here are some examples of attribute path names: </p><div class="fragment"><div class="line">xcm.blocking</div>
<div class="line">tls.peer.cert.san.emails[2]</div>
</div><!-- fragment --><h2><a class="anchor" id="attribute_values"></a>
Attribute Values</h2>
<p>The attribute's value is coded in the native C data type and native CPU byte order. Strings are NUL-terminated, and the NUL character is included in the length of the attribute. There are four value types; a boolean type, a 64-bit signed integer type, a string type, a type for arbitrary binary data, and a double-precision floating point type. See <a class="el" href="xcm__attr__types_8h.html" title="XCM attribute value type definitions.">xcm_attr_types.h</a> for details.</p>
<p>In the current API, only leaf nodes can be accessed (e.g., it's not possible to retrieve a list or a dictionary as a single call).</p>
<p>The attribute access API is in <a class="el" href="xcm__attr_8h.html" title="XCM socket attribute access API.">xcm_attr.h</a>.</p>
<h2><a class="anchor" id="attribute_structure"></a>
Basic Structure</h2>
<p>The socket attribute tree has an unnamed root. This root dictionary has a number of keys.</p>
<p>The generic XCM attributes, available in all transports, are organized under the "xcm" key. Transport-specific attributes are prefixed with the transport or protocol name (e.g. "tcp" for TCP-specific attributes applicable to the TLS, BTLS, TCP, and BTCP transports).</p>
<h2><a class="anchor" id="attribute_access"></a>
Attribute Access</h2>
<p>Retrieving the value of an attribute is done using <a class="el" href="xcm__attr_8h.html#accaa82dfb750ba09b9d999a8ce59d95f">xcm_attr_get()</a>, or any of its many type-specific convenience functions.</p>
<p>Below is an example of reading an integer attribute value. </p><div class="fragment"><div class="line">int64_t rtt;</div>
<div class="line">xcm_attr_get_int(tcp_conn_socket, <span class="stringliteral">&quot;tcp.rtt&quot;</span>, &amp;rtt);</div>
<div class="line">printf(<span class="stringliteral">&quot;Current TCP round-trip time estimate is %ld us.&quot;</span>, rtt);</div>
</div><!-- fragment --><p>Iterating over a list may look something like below. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> len = <a class="code hl_function" href="xcm__attr_8h.html#a2882a3e859836e2336538f43669ff1ba">xcm_attr_get_list_len</a>(tls_conn_socket, <span class="stringliteral">&quot;tls.peer.cert.san.dns&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; i++) {</div>
<div class="line">    <span class="keywordtype">char</span> name[256];</div>
<div class="line">    <a class="code hl_function" href="xcm__attr_8h.html#ade8e1a794840f09b821eacb6443b6c0c">xcm_attr_getf_str</a>(tls_conn_socket, name, <span class="keyword">sizeof</span>(name),</div>
<div class="line">                      <span class="stringliteral">&quot;tls.peer.cert.san.dns[%d]&quot;</span>, i);</div>
<div class="line">    printf(<span class="stringliteral">&quot;DNS subject alternative name: %s\n&quot;</span>, name);</div>
<div class="line">}</div>
<div class="ttc" id="axcm__attr_8h_html_a2882a3e859836e2336538f43669ff1ba"><div class="ttname"><a href="xcm__attr_8h.html#a2882a3e859836e2336538f43669ff1ba">xcm_attr_get_list_len</a></div><div class="ttdeci">int xcm_attr_get_list_len(struct xcm_socket *socket, const char *list_name)</div></div>
<div class="ttc" id="axcm__attr_8h_html_ade8e1a794840f09b821eacb6443b6c0c"><div class="ttname"><a href="xcm__attr_8h.html#ade8e1a794840f09b821eacb6443b6c0c">xcm_attr_getf_str</a></div><div class="ttdeci">int xcm_attr_getf_str(struct xcm_socket *socket, char *value, size_t capacity, const char *name_fmt,...)</div></div>
</div><!-- fragment --><p>Modyfing the value of an attribute is done using <a class="el" href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set()</a>, or any of its many type-specific convenience functions.</p>
<p>For example, setting the value of a boolean attribyte may be done like below. </p><div class="fragment"><div class="line"><a class="code hl_function" href="xcm__attr_8h.html#abac895b2add081512bbc59eca02b9c55">xcm_attr_set_bool</a>(tcp_conn_socket, <span class="stringliteral">&quot;tcp.keepalive&quot;</span>, <span class="keyword">false</span>);</div>
<div class="ttc" id="axcm__attr_8h_html_abac895b2add081512bbc59eca02b9c55"><div class="ttname"><a href="xcm__attr_8h.html#abac895b2add081512bbc59eca02b9c55">xcm_attr_set_bool</a></div><div class="ttdeci">int xcm_attr_set_bool(struct xcm_socket *socket, const char *name, bool value)</div></div>
</div><!-- fragment --><p>Please note that all of these examples lack the error handling required in a real application.</p>
<h2><a class="anchor" id="attr_bulk"></a>
Socket Instantiation Configuration</h2>
<p>An application may modify multiple attributes in one go, as a part of socket creation, by populating an attribute map and passing it to <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a>, <a class="el" href="xcm_8h.html#a6b334574c9e1b15af4c0350d8b7cf9ad">xcm_server_a()</a>, or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a>.</p>
<p>Certain attributes' default values (e.g., attribute controlling what TLS credentials are used) may only be modified in this manner.</p>
<p>Each key-value pair in the attribute maps is used as an instruction to set a node in the socket attribute tree to a particular value. The node's path is the key's name, and new desired value of the node is the key's value.</p>
<p>The attribute sets are represented by the <code>xcm_attr_map</code> type in <a class="el" href="xcm__attr__map_8h.html" title="XCM attribute map API.">xcm_attr_map.h</a>.</p>
<p>The caller retains the ownership of the attribute map passed to <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a>, <a class="el" href="xcm_8h.html#a6b334574c9e1b15af4c0350d8b7cf9ad">xcm_server_a()</a>, or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a>, and may destroy it after the call has completed, or reuse it.</p>
<p>A somewhat contrived example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>xcm_attr_map *attrs = <a class="code hl_function" href="xcm__attr__map_8h.html#a128624b0a4d5ffe8defb482c63f6396e">xcm_attr_map_create</a>();</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#ad618223af0a37c2c55814f84e8d27637">xcm_attr_map_add_bool</a>(attrs, <span class="stringliteral">&quot;xcm.blocking&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#a3f1421bc7c615faa5370158f08b77644">xcm_attr_map_add_str</a>(attrs, <span class="stringliteral">&quot;xcm.local_addr&quot;</span>, <span class="stringliteral">&quot;tls:192.168.1.42:0&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#ad618223af0a37c2c55814f84e8d27637">xcm_attr_map_add_bool</a>(attrs, <span class="stringliteral">&quot;tls.verify_peer_name&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#a3f1421bc7c615faa5370158f08b77644">xcm_attr_map_add_str</a>(attrs, <span class="stringliteral">&quot;tls.peer_names&quot;</span>, <span class="stringliteral">&quot;myservice&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#a621c6f6e5d062f1d28ebbc9cc79be730">xcm_attr_map_add_int64</a>(attrs, <span class="stringliteral">&quot;tcp.keepalive_interval&quot;</span>, 10);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>xcm_socket *conn = <a class="code hl_function" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a</a>(<span class="stringliteral">&quot;tls:192.168.1.99:4711&quot;</span>, attrs);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#aeafbfc82e1229a77233dd7811e175fb5">xcm_attr_map_destroy</a>(attrs);</div>
<div class="ttc" id="axcm_8h_html_ae8e67bc6e21a33371bd273e089d6d741"><div class="ttname"><a href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a</a></div><div class="ttdeci">struct xcm_socket * xcm_connect_a(const char *remote_addr, const struct xcm_attr_map *attrs)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_a128624b0a4d5ffe8defb482c63f6396e"><div class="ttname"><a href="xcm__attr__map_8h.html#a128624b0a4d5ffe8defb482c63f6396e">xcm_attr_map_create</a></div><div class="ttdeci">struct xcm_attr_map * xcm_attr_map_create(void)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_a3f1421bc7c615faa5370158f08b77644"><div class="ttname"><a href="xcm__attr__map_8h.html#a3f1421bc7c615faa5370158f08b77644">xcm_attr_map_add_str</a></div><div class="ttdeci">void xcm_attr_map_add_str(struct xcm_attr_map *attr_map, const char *attr_name, const char *attr_value)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_a621c6f6e5d062f1d28ebbc9cc79be730"><div class="ttname"><a href="xcm__attr__map_8h.html#a621c6f6e5d062f1d28ebbc9cc79be730">xcm_attr_map_add_int64</a></div><div class="ttdeci">void xcm_attr_map_add_int64(struct xcm_attr_map *attr_map, const char *attr_name, int64_t attr_value)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_ad618223af0a37c2c55814f84e8d27637"><div class="ttname"><a href="xcm__attr__map_8h.html#ad618223af0a37c2c55814f84e8d27637">xcm_attr_map_add_bool</a></div><div class="ttdeci">void xcm_attr_map_add_bool(struct xcm_attr_map *attr_map, const char *attr_name, bool attr_value)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_aeafbfc82e1229a77233dd7811e175fb5"><div class="ttname"><a href="xcm__attr__map_8h.html#aeafbfc82e1229a77233dd7811e175fb5">xcm_attr_map_destroy</a></div><div class="ttdeci">void xcm_attr_map_destroy(struct xcm_attr_map *attr_map)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="xcm_attr_inheritance"></a>
Attribute Inheritance</h2>
<p>Connection sockets spawned off a server sockets will inherit the server socket's attributes that also applies to connection sockets. An application may override such values by passing a different values in the <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> call.</p>
<h2><a class="anchor" id="xcm_attr"></a>
Generic Attributes</h2>
<p>These attributes are expected to be found on XCM sockets regardless of transport type.</p>
<p>For TCP and BTCP transport-specific attributes, see <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a>, and for TLS and BTLS, see <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>. For DNS-related attributes (shared among all TCP-based transports) see <a class="el" href="index.html#dns_attr">DNS Socket Attributes</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.type   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The socket type: "server" or "connection".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.transport   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The transport type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.service   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The service type: "messaging" or "bytestream". Writable only at the time of socket creation. If specified, it may be used by an application to limit the type of transports being used. The string "any" may be used to signify that any type of service is accepted. The default value is "messaging".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.local_addr   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The local address of a socket. Writable only if supplied to <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> together with a TLS, UTLS or TCP type address. Usually only needs to be written on multihomed hosts, in cases where the application needs to specify the source IP address to be used. Also see <a class="el" href="xcm_8h.html#a7fefa1353b41c2445e13603e80f56336">xcm_local_addr()</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.blocking   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">See <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> and <a class="el" href="xcm_8h.html#a6cfdb3e1a859549d686c93b32c6a6818">xcm_is_blocking()</a>. The default value is true.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.remote_addr   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">See <a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr()</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.max_msg_size   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The local maximum size of any message transported by this connection. The remote end may have a different opinion on what is the upper limit.   </td></tr>
</table>
<h3><a class="anchor" id="cnt_attr"></a>
Generic Counter Attributes</h3>
<p>XCM connections sockets keeps track of the amount of data entering or leaving the XCM layer, both from the application and to the lower layer. Additionally, messaging transports also track the number of messages.</p>
<p>Some of the message and byte counter attributes use the concept of a "lower layer". What this means depends on the transport. For the UX and TCP transports, it is the Linux kernel. For example, for TCP, if the xcm.to_lower_msgs is incremented, it means that XCM has successfully sent the complete message to the kernel's networking stack for further processing. It does not means it has reached the receiving process. It may have, but it also may be sitting on the local or remote socket buffer, on a NIC queue, or be in-transmit in the network. For TLS, the lower layer is OpenSSL.</p>
<p>The counters only reflect data succesfully sent and/or received.</p>
<h4><a class="anchor" id="common_cnt_attr"></a>
Byte Counter Attributes</h4>
<p>These counters are available on both byte stream and messaging type connection sockets.</p>
<p>The byte counters are incremented with the length of the XCM data (as in the length field in <a class="el" href="xcm_8h.html#af3fa59a1297e444a001b6392d073718d">xcm_send()</a>), and thus does not include any underlying headers or other lower layer overhead.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_app_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Bytes sent from the application and accepted into XCM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_app_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Bytes delivered from XCM to the application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_lower_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Bytes received by XCM from the lower layer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_lower_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Bytes successfully sent by XCM into the lower layer.   </td></tr>
</table>
<h4><a class="anchor" id="messaging_cnt_attr"></a>
Message Counter Attributes</h4>
<p>These counters are available only on messaging type connection sockets.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_app_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages sent from the application and accepted into XCM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_app_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages delivered from XCM to the application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_lower_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages received by XCM from the lower layer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_lower_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages successfully sent by XCM into the lower layer.   </td></tr>
</table>
<h1><a class="anchor" id="ctl"></a>
Control Interface</h1>
<p>XCM includes a control interface, which allows iteration over the OS instance's XCM server and connection sockets (for processes with the appropriate permissions), and access to their attributes (see <a class="el" href="index.html#attributes">Socket Attributes</a>).</p>
<p>Security-sensitive attributes (e.g., <code>tls.key</code>) cannot be accessed.</p>
<p>The control interface is optional by means of build-time configuration.</p>
<p>For each XCM server or connection socket, there is a corresponding UNIX domain socket which is used for control signaling (i.e. state retrieval).</p>
<h2><a class="anchor" id="ctl_dir"></a>
Control UNIX Socket Directory</h2>
<p>By default, the control interface's UNIX domain sockets are stored in the <code>/run/xcm/ctl</code> directory.</p>
<p>This directory should to be created prior to running any XCM applications for the control interface to worker properly and should be writable for all XCM users.</p>
<p>A particular process using XCM may be configured to use a non-default directory for storing the UNIX domain sockets used for the control interface by means of setting the <code>XCM_CTL</code> variable. Please note that using this setting will cause the XCM connections to be not visible globally on the OS instance (unless all other XCM-using processes also are using this non-default directory).</p>
<h2><a class="anchor" id="ctl_errors"></a>
Control Interface Error Handling</h2>
<p>Generally, since the application is left unaware (from an API perspective) of the existence of the control interface, errors are not reported up to the application. They are however logged.</p>
<p>Application threads owning XCM sockets, but which are busy with non-XCM processing for a long duration of time, or otherwise are leaving their XCM sockets unattended to (in violation of XCM API contract), will not respond on the control interface's UNIX domain sockets (corresponding to their XCM sockets). Only the presence of these sockets may be detected, but their state cannot be retrieved.</p>
<h2><a class="anchor" id="ctl_api"></a>
Control API</h2>
<p>Internally, the XCM implementation has control interface client library, but this library's API is not public at this point.</p>
<h2><a class="anchor" id="ctl_shell"></a>
Command-line Control Program</h2>
<p>XCM includes a command-line program <code>xcmctl</code> which uses the <a class="el" href="index.html#ctl_api">Control API</a> to iterate of the system's current XCM sockets, and allow access (primarily for debugging purposes) to the sockets' attributes.</p>
<h1><a class="anchor" id="thread_safety"></a>
Thread Safety</h1>
<p>XCM API calls are MT safe provided the threads do not operate on the same socket, at the same time.</p>
<p>Thus, multiple threads may make XCM API calls in parallel, provided the calls refer to different XCM sockets.</p>
<p>An XCM socket may not be shared among different threads without synchronization external to XCM. Provided calls are properly serialized (e.g., with a mutex lock), a socket may be shared by different threads in the samea process. However, this might prove difficult since a thread in a blocking XCM function will continue to hold the lock, preventing other threads from accessing the socket.</p>
<p>For non-blocking sockets (with external synchronization), threads sharing a socket need to agree on what is the appropriate socket <code>condition</code> to wait for. When this condition is met, all threads are woken up, returning from select().</p>
<p>It is safe to "give away" an XCM socket from one thread to another, provided the appropriate memory fences are used.</p>
<p>These limitations (compared to BSD Sockets) are in place to allow socket state outside the kernel (which is required for TCP framing and TLS).</p>
<h1><a class="anchor" id="fork"></a>
Multi-processing and Fork</h1>
<p>Sharing an XCM socket between threads in different processes is not possible.</p>
<p>After a fork() call, either of the two process (the parent, or the child) must be designated the owner of every XCM socket the parent owned.</p>
<p>The owner may continue to use the XCM socket normally.</p>
<p>The non-owner may not call any other XCM API call than <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a>, which frees local memory tied to this socket in the non-owner's process address space, without impacting the connection state in the owner process.</p>
<h1><a class="anchor" id="transports"></a>
Transports</h1>
<p>The core XCM API functions are oblivious to the transports used. However, the support for building, and parsing addresses are available only for a set of pre-defined set of transports. There is nothing preventing <a class="el" href="xcm__addr_8h.html" title="API for parsing and building XCM addresses.">xcm_addr.h</a> from being extended, and also nothing prevents an alternative XCM implementation to include more transports without extending the address helper API.</p>
<h2><a class="anchor" id="ux_transport"></a>
UX Transport</h2>
<p>The UX transport uses UNIX Domain (AF_UNIX, also known as AF_LOCAL) Sockets to providing a service of the messaging type.</p>
<p>UX sockets may only be used with the same OS instance (or, more specifically, between processes in the same Linux kernel network namespace).</p>
<p>UNIX Domain Sockets comes in a number of flavors, and XCM uses the SOCK_SEQPACKET variety. SOCK_SEQPACKET sockets are connection-oriented, preserves message boundaries and delivers messages in the same order they were sent; perfectly matching XCM semantics and provides for an near-trivial mapping.</p>
<p>UX is the most efficient of the XCM transports.</p>
<p>The UX transport has a nominal maximum message size of 262144 bytes. This limit may be lower due to conservative kernel runtime configuration (i.e., low <code>net.core.wmem_max</code> values). In such cases, the <code>xcm.max_msg_size</code> will reflect the actual upper limit, at the time of socket creation. The max message size may change in future versions of the UX transport.</p>
<h3><a class="anchor" id="ux_naming"></a>
UX Namespace</h3>
<p>The standard UNIX Domain Sockets as defined by POSIX uses the file system as its namespace, with the sockets also being files. However, for simplicity and to avoid situations where stale socket files (originating from crashed processes) causing problems, the UX transport uses a Linux-specific extension, allowing a private UNIX Domain Socket namespace. This is known as the abstract namespace (see the unix(7) man page for details). With the abstract namespace, server socket address allocation has the same life time as TCP ports (i.e. if the process dies, the address is free'd).</p>
<p>The UX transport enables the SO_PASSCRED BSD socket option, to give the remote peer a name (which UNIX domain connection socket doesn't have by default). This is for debugging and observability purposes. Without a remote peer name, in server processes with multiple incoming connections to the same server socket, it's difficult to say which of the server-side connection sockets goes to which remote peer. The kernel-generated, unique, name is an integer in the form "%05x" (printf format). Applications using hardcoded UX addresses should avoid such names by, for example, using a prefix.</p>
<p>The <a class="el" href="index.html#utls_transport">UTLS Transport</a> also indirectly uses the UX namespace, so care should be taken to avoid any clashes between UX and UTLS sockets in the same network namespace.</p>
<h2><a class="anchor" id="uxf_transport"></a>
UXF Transport</h2>
<p>The UXF transport is identical to the UX transport, only it uses the standard POSIX naming mechanism. The name of a server socket is a file system path, and the socket is also a file.</p>
<p>The UXF sockets resides in a file system namespace, as opposed to UX sockets, which live in a network namespace.</p>
<p>Upon <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a>, the socket will be closed and the file removed. If an application crashes or otherwise fails to run <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a>, it will leave a file in the file system pointing toward a non-existing socket. This file will prevent the creation another server socket with the same name.</p>
<h2><a class="anchor" id="tcp_transport"></a>
TCP Transport</h2>
<p>The TCP transport uses the Transmission Control Protocol (TCP), by means of the BSD Sockets API.</p>
<p>TCP is a byte-stream service, but the XCM TCP transport adds framing on top of the stream. A single-field 32-bit header containing the message length in network byte order is added to every message.</p>
<p>TCP uses TCP Keepalive to detect lost network connectivity between the peers.</p>
<p>The TCP transport has a maximum message size of 262144 bytes. This limit may change in future versions.</p>
<p>The TCP transport supports IPv4 and IPv6.</p>
<p>Since XCM is designed for signaling traffic, the TCP transport disables the Nagle algorithm of TCP to avoid its excessive latency.</p>
<h3><a class="anchor" id="dns_attr"></a>
DNS Socket Attributes</h3>
<p>The TLS transport (and all other TCP protocol-based transports) supports a number of socket attributes controlling DNS-related behavior.</p>
<h4><a class="anchor" id="dns_algorithm_attr"></a>
DNS Resolution and TCP Connection Establishment</h4>
<p>The DNS resolver used by XCM (either glibc or C-ares) sorts the A and AAAA records retrieved from DNS in an order of preference, before returning them to the caller. In the glibc case, the details of the sorting is a function of the system's configuration (i.e. /etc/gai.conf). In the C-ares case, the sorting is according to RFC 6724 (with some minor deviations).</p>
<p>By default, XCM will only attempt to connect to the first, most preferred, address in the list of IP addresses provided by the resolver. If that connection attempt fails, the XCM connection establishment procedure will be terminated.</p>
<p>Using the "dns.algorithm" socket attribute, the application may control the DNS resolution and TCP connection establishment procedure used.</p>
<p>By default, "dns.algorithm" is set to "single", behaving in accordance to the above description.</p>
<p>If the algorithm is set to "sequential", all IP addresses will be probed, in a serial manner, in the order provided by the DNS resolver.</p>
<p>Setting the algorithm to "happy_eyeballs" will result in RFC 6555-like behavior, with two concurrent connection establishment tracks; one attempting to establish an IPv4 connection and the other an IPv6-based connection. The IPv6 track is given a 200 ms head start.</p>
<p>When the "sequential" or "happy_eyeballs" algorithm is used, only the first 32 addresses provided by the resolver will be considered.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dns.algorithm   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The algorithm used for connecting to IP addresses retrieved from DNS. Must take on the value "single", "sequential", or "happy_eyeballs". See <a class="el" href="index.html#dns_algorithm_attr">DNS Resolution and TCP Connection Establishment</a> for more information. Writable only at the time of the <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dns.timeout   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) until DNS resolution times out. Writable only at the time of the <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call. The timeout covers the complete DNS resolution process (as opposed to a particular query-response transaction). Only available when the library is built with the c-ares DNS resolver.   </td></tr>
</table>
<h3><a class="anchor" id="tcp_attr"></a>
TCP Socket Attributes</h3>
<p>The read-only TCP attributes are retrieved from the kernel (struct tcp_info in linux/tcp.h).</p>
<p>Many read-write attributes are mapped directly to setsockopt() calls.</p>
<p>See the tcp(7) manual page for a more detailed description of these attributes. The struct retrieved with <code>TCP_INFO</code> is the basis for the read-only attributes. The read-write attributes are mapped to <code>TCP_KEEP*</code> and <code>TCP_USER_TIMEOUT</code>.</p>
<p>Besides the TCP layer attributes, IP- and DNS-level attributes are also listed here.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.rtt   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The current TCP round-trip estimate (in us).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.total_retrans   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The total number of retransmitted TCP segments.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.segs_in   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The total number of segments received.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.segs_out   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The total number of segments sent.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.connect_timeout   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) until a particular TCP connection establishment attempt times out. Writable only at the time of the <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call. The default is 3 s. The value of this attribute must be lower than the value of "tcp.user_timeout" to have any effect. Note that if "dns.algorithm" is set to "sequential" or "happy_eyeballs", one <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call may result in several TCP connection establishment attempts.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.user_timeout   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) before a connection is dropped due to unacknowledged data. The default value is 3 s.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.keepalive   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls if TCP keepalive is enabled. The default value is true.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.keepalive_time   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) before the first keepalive probe is sent on an idle connection. The default value is 1 s.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.keepalive_interval   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) between keepalive probes. The default value is 1 s.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.keepalive_count   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The number of keepalive probes sent before the connection is dropped. The default value is 3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ipv6.scope   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The IPv6 scope id used. Only available on IPv6 sockets. Writable only at socket creation. If left unset, it will take on the value of 0 (the global scope). Any other value denotes the network interface index to be used, for IPv6 link local addresses. See the if_nametoindex(3) manual page for how to map interface names to indices.   </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd><code>tcp.segs_in</code> and <code>tcp.segs_out</code> are only present when running XCM on Linux kernel 4.2 or later.</dd></dl>
<h2><a class="anchor" id="tls_transport"></a>
TLS Transport</h2>
<p>The TLS transport uses the Transport Layer Security (TLS) protocol to provide a secure, private, two-way authenticated transport over TCP. A TLS connection is a byte stream, but the XCM TLS transport adds framing in the same manner as does the XCM TCP transport.</p>
<p>The TLS transport supports IPv4 and IPv6. It disables the Nagle algorithm of TCP.</p>
<p>The TLS transport has a maximum message size of 262144 bytes. This limit may change in future versions.</p>
<p>The TLS transport honors any limitations set by the X.509 extended key usage extension, if present in the remote peer's certificate.</p>
<h3><a class="anchor" id="tls_version"></a>
TLS Protocol Version and Features</h3>
<p>The TLS transport supports TLS 1.2 and 1.3, only. By default, both 1.2 and 1.3 are enabled. The <code>tls.12.enabled</code> and <code>tls.13.enabled</code> socket attributes (see <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>) may be used to disabled a protocol version.</p>
<p>TLS 1.2 renegotiation is disabled, if the XCM library is built with OpenSSL 1.1.1c or later.</p>
<p>The TLS transport disables both client and server-side TLS session caching, and thus does not allow for TLS session reuse across TCP connections.</p>
<h3><a class="anchor" id="tls_ciphers"></a>
Cipher Suites</h3>
<p>XCM TLS server and connection sockets have two lists of accepted cipher suites; one for TLS 1.2 and another for TLS 1.3. The lists are ordered, with the most-preferred cipher suite first.</p>
<p>The default lists may be overridden by using the <code>tls.12.ciphers</code> and <code>tls.13.ciphers</code> socket attributes (see <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>) at the time of socket creation.</p>
<p>Which cipher suites may be configured depends on which OpenSSL version the XCM library is linked against.</p>
<p>IANA names (and not OpenSSL names, nor IANA hex codes) are used in the cipher suite-related XCM socket attributes.</p>
<dl class="section user"><dt>Default Ciphers</dt><dd></dd></dl>
<p>Default TLS 1.2 cipher suites:</p><ul>
<li>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</li>
<li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</li>
<li>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256</li>
</ul>
<p>Default TLS 1.3 cipher suites:</p><ul>
<li>TLS_AES_256_GCM_SHA384</li>
<li>TLS_CHACHA20_POLY1305_SHA256</li>
<li>TLS_AES_128_GCM_SHA256</li>
</ul>
<p>Default cipher suites may change between XCM versions, as deprecated or weak cipher suites are removed and new ciphers are added.</p>
<h3><a class="anchor" id="tls_groups"></a>
Groups</h3>
<p>The default named groups (also called elliptic curves) of the underlying SSL library may be overriden using the write-only <code>tls.groups</code> socket attribute (see <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>) at the time of socket creation.</p>
<h3><a class="anchor" id="tls_certificates"></a>
Certificate and Key Handling</h3>
<p>By default, the TLS transport reads the leaf certificate and the corresponding private key from the file system, as well as a file containing all trusted CA certificates. The default file system paths are configured at build-time.</p>
<p><a class="el" href="index.html#tls_attr">TLS Socket Attributes</a> may be used to override one or more of the default paths, on a per-socket basis. Paths set on server sockets are inherited by its connection sockets, but may in turn be overriden at the time of an <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> call, using the proper attributes.</p>
<p>The default paths may also be overriden on a per-process basis by means of setting a UNIX environment variable. The current value of <code>XCM_TLS_CERT</code> (at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>) determines the certificate directory used for that connection.</p>
<p>An application may also choose to configure TLS socket credentials by-value, rather than by-file-system-reference. For a particular piece of information, an application must use either supply a file system path (e.g., by setting <code>tls.cert_file</code>) or the actual data (e.g., by passing the certificate data as the value of the <code>tls.cert</code> attribute).</p>
<p>Setting a credentials by-value attribute in the <code>xcm_attr_map</code> passed to <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> will override the corresponding by-reference attribute in the server socket, and vice versa.</p>
<h4><a class="anchor" id="credentials_format"></a>
Certificate and Key Format</h4>
<p>Certificates (including CRLs) and private keys provided to XCM (either via files or by attribute value) must be in the Privacy-Enhanced Mail (PEM) format (RFC 7468).</p>
<h4><a class="anchor" id="per_ns_certs"></a>
Per-network Namespace Certificates</h4>
<p>The TLS transport will, at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> or <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>, look up the process' current network namespace, unless that file's path was given as a <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>. If the namespace is given a name per the iproute2 convention, XCM will retrieve this name and use it in the certificate and key lookup.</p>
<p>In case the certificate, key and trusted CA files are configured using <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>, no network namespace lookup will be performed.</p>
<p>In the certificate directory (either the compile-time default, or the directory specified with <code>XCM_TLS_CERT</code>), the TLS transport expects the files to follow the following naming conventions (where &lt;ns&gt; is the namespace): </p><div class="fragment"><div class="line">cert_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The private key is stored in: </p><div class="fragment"><div class="line">key_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The trusted CA certificates are stored in: </p><div class="fragment"><div class="line">tc_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The certification revocation lists (CRLs) are stored in: </p><div class="fragment"><div class="line">crl_&lt;ns&gt;.pem</div>
</div><!-- fragment --><h4><a class="anchor" id="default_certs"></a>
Default Namespace Certificates</h4>
<p>For the default namespace (or rather, any network namespace not named according to iproute2 standards), the certificate need to be stored in a file "cert.pem" and the private key in "key.pem".</p>
<p>If authentication is enabled (which it is, by default), the trusted CA certificates need to be stored in a file named "tc.pem".</p>
<p>If CRL checking is enabled (which it is not, by default), the CRLs need to be stored in a file named "crl.pem".</p>
<p>In case the appropriate credential-related files are not in place (for a particular namespace), an <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> call will return an error and set errno to EPROTO. The application may choose to retry at a later time.</p>
<p>If authentication is disabled, "tc.pem" need not be present, and vice versa. The same applies to CRL checking and "crl.pem" availability.</p>
<h4><a class="anchor" id="cert_update"></a>
Runtime Certificate File Updates</h4>
<p>In case a certificate, private key, or trusted CAs file is modified, the new version of the file(s) will be used by new connections. Such a change does not affect already-established connections. The TLS transport works with differences between set of files, and thus the new generation of files need not nesserarily be newer (as in having a more recent file system mtime).</p>
<p>The certificate, key and trusted CA certificates should be updated in an atomic manner, or XCM may end up using the certificate file from one generation of files and the key file from another, for example.</p>
<p>One way of achieving an atomic update is to have the three files in a common directory. This certificate directory is then made a symbolic link to the directory where the actual files are located. Upon update, a new directory is created and populated, and the old symbolic link is replace an atomic manner (i.e. with rename(2)).</p>
<h3><a class="anchor" id="tls_role"></a>
Role Configuration</h3>
<p>By default, on sockets that represent the client side of an XCM TLS connection (e.g., returned from <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a>), the XCM TLS transport will act as a TLS client. Similarly, the default behavior for sockets representing the XCM (and TCP) server side of a connection is to act as a TLS server.</p>
<p>The default may be changed by setting the "tls.client" attribute, so that sockets that are XCM (and TCP) level clients, act as TLS servers, and vice versa. If the value is true, the socket will act as a TLS client, and if false, the socket is a TLS server.</p>
<p>Connection sockets created by <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> inherit the "tls.client" attribute value from their parent server sockets.</p>
<p>The TLS role must be specified at the time of socket creation, and thus cannot be changed on already-established connections.</p>
<h3><a class="anchor" id="tls_auth"></a>
Authentication</h3>
<p>By default, both the client and server side authenticate the other peer, often referred to as <em>mutual TLS</em> (mTLS).</p>
<p>TLS remote peer authentication may be disabled by setting the "tls.auth" socket attribute to false. The default value is true.</p>
<p>Connection sockets created by <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> inherit the "tls.auth" attribute value from their parent server sockets.</p>
<p>The "tls.auth" socket attribute may only be set at the time of socket creation (except for server sockets).</p>
<h3><a class="anchor" id="name_verification"></a>
X.509v3 Subject Name Verification</h3>
<p>The TLS transport supports verifying the remote peer's certificate subject name against an application-specified expected name, or a set of names. "Subject name" here is used as per RFC 6125 definition, and is either a Distingushed Name (DN) of the X.509 certificate's subject field, or a DNS type subject alternative name extension. XCM does not make any distinction between the two.</p>
<p>Subject name verification may be enabled by setting the "tls.verify_peer_name" socket attribute to true. It is disabled by default.</p>
<p>If enabled, XCM will verify the hostname in the address supplied in the <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call. In case the attribute "tls.peer_names" is also supplied, it overrides this behavior. The value of this attribute is a ':'-separated set of subject names. "tls.peer_names" may not be set unless "tls.verify_peer_name" is set to true.</p>
<p>If there is a non-zero overlap between these two sets, the verification is considered successful. The actual procedure is delegated to OpenSSL. Wildcard matching is disabled (<code>X509_CHECK_FLAG_NO_WILDCARDS</code>) and the check includes the subject field (<code>X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT</code>).</p>
<p>Subject name verification may be used both by a client (in its <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> call) or by a server (in <a class="el" href="xcm_8h.html#a6b334574c9e1b15af4c0350d8b7cf9ad">xcm_server_a()</a> or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a>). "tls.peer_names" must be specified in case "tls.verify_peer_name" is set to true on connection sockets created by accepting a TLS connection from a server socket (since there is no hostname to fall back to).</p>
<p>Connection sockets created by <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> inherit the "tls.verify_name" and "tls.peer_names" attributes from their parent server sockets.</p>
<p>After a connection is established, the "tls.peer_names" will be updated to reflect the remote peer's actual subject names, as opposed to those which were originally allowed.</p>
<p>OpenSSL refers to this functionality as hostname validation, and that is also how it's usually used. However, the subject name passed in "tls.peer_names" need not be DNS domain name, but can be any kind of name or identifier. All names must follow DNS domain name syntax rules (including label and total length limitations). Also, while uppercase and lowercase letters are allowed in domain names, no significance is attached to the case.</p>
<h3><a class="anchor" id="crl_checks"></a>
Certification Revocation List Checks</h3>
<p>The XCM TLS transport may be asked to perform checks against one or more Certificate Revocation Lists (CRLs).</p>
<p>CRL checking is enabled by setting the "tls.check_crl" socket attribute to true during socket creation (e.g., when calling <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a>). CRL checking is disabled by default. CRL checking may be employed by both TLS client and server endpoints.</p>
<p>The default CRL file location may be overriden using the "tls.crl_file" attribute. Alternatively, the CRL data may be provided by-value using the "tls.crl" attribute.</p>
<p>The CRL bundle must be in PEM format, and must be present and valid if CRL checking is enabled.</p>
<p>The full chain is checked against the user-provided CRLs (i.e., in OpenSSL terms, both the X509_V_FLAG_CRL_CHECK and X509_V_FLAG_CRL_CHECK_ALL flags are set).</p>
<p>CRL checking is only meaningful (and allowed) when authentication is enabled.</p>
<p>Due to a bug in OpenSSL, partial chains (i.e., where the trust anchor is a trusted non-root certificate) is not allowed when CRL checking is enabled. In OpenSSL terms, X509_V_FLAG_PARTIAL_CHAIN is disabled when X509_V_FLAG_CRL_CHECK_ALL is enabled. Future versions of XCM, built against newer versions of OpenSSL, may allow partial chains in combination with CRL checking.</p>
<h3><a class="anchor" id="validity_checks"></a>
Certificate Validity Period Checks</h3>
<p>By default, the XCM TLS transport checks the validity period of each X.509 certificate in the chain of trust, down to and including the remote peer's leaf certificate, against the current system time. If any certificate is found to be either not yet valid or expired, TLS connection establishment is aborted.</p>
<p>A socket may be configured to accept not-yet-valid certificates and expired certificates by setting the "tls.check_time" to false.</p>
<p>Connection sockets created by <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> inherit the "tls.check_time" attribute value from their parent server sockets.</p>
<h3><a class="anchor" id="tls_attr"></a>
TLS Socket Attributes</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.cert_file   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The leaf certificate file. Writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.key_file   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The leaf certificate private key file. Writable only at socket creation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.tc_file   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The trusted CA certificates bundle file. Writable only at socket creation. May not be set if authentication is disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.crl_file   </td><td class="markdownTableBodyNone">Al l   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The certificate verification list (CRL) bundle. Writable only at socket creation. May only be set if CRL checking is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.cert   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Binary   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The leaf certificate to be used. Writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.key   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Binary   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The leaf certificate private key to be used. Writable only at socket creation. For security reasons, the value of this attribute is not available over the XCM control interface.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.tc   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Binary   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The trusted CA certificates bundle to be used. Writable only at socket creation. May not be set if authentication is disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.crl   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Binary   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The certificate verification list (CRL) bundle to be used. Writable only at socket creation. May only be set if CRL checking is enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.client   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls whether to act as a TLS-level client or a server. Writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.auth   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls whether or not to authenticate the remote peer. Writable only at socket creation. Default value is true.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.12.enabled   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls whether or not TLS v1.2 may be used. Writable only at socket creation. Default value is true.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.13.enabled   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls whether or not TLS v1.3 may be used. Writable only at socket creation. Default value is true.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.12.ciphers   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Colon-separated list of TLS v1.2 cipher suites. Writable only at socket creation. See <a class="el" href="index.html#tls_ciphers">Cipher Suites</a> for more information.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.13.ciphers   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Colon-separated list of TLS v1.3 cipher suites. Writable only at socket creation. See <a class="el" href="index.html#tls_ciphers">Cipher Suites</a> for more information.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.groups   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">WO   </td><td class="markdownTableBodyNone">Colon-separated list of named groups (elliptic curves). Writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.check_crl   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls whether or not to perform CRL checking. Writable only at socket creation. Default value is false.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.check_time   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls if the X.509 certificate validity period is honored. Writable only at socket creation. Default is true.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.verify_peer_name   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls if subject name verification should be performed. Writable only at socket creation. Default value is false.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.peer_names   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">At socket creation, a list of acceptable peer subject names. After the TLS handshake has completed, a list of actual peer subject names. Writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.version   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The actual, negotiated TLS protocol version ("1.2" for TLS v1.2 and "1.3" for TLS v1.3). Available after the TLS handshake has completed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.cipher   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The IANA name of the actual, negotiated TLS cipher suite used. Available after the TLS handshake has completed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.peer_subject_key_id   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The X509v3 Subject Key Identifier of the remote peer, or a zero-length string in case no certificate available (e.g, the TLS connection is not established or TLS authentication is disabled and the remote peer did not send a certificate).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.peer.cert.subject.cn   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The common name (CN) of the remote peer's subject field, provided the certificate (including a CN in the subject DN) exists.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.peer.cert.san.dns   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">List   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">A list of strings, where each element is a remote peer's subject alternative name (SAN) of the DNS type. The subject field CN is not included in this list.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.peer.cert.san.emails   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">List   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">A list of strings, where each element is a remote peer's SAN of the RFC 822 type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.peer.cert.san.dirs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">List   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">A list of dictionaries. Each element represents is a remote peer's SAN of the directory name type, and contains the key "cn", holding the directory name DN's CN, if the CN is present.   </td></tr>
</table>
<p>In addition to the TLS-specific attributes, a TLS socket also has all the <a class="el" href="index.html#dns_attr">DNS Socket Attributes</a> and <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a> (including the IP-level attributes).</p>
<h2><a class="anchor" id="utls_transport"></a>
UTLS Transport</h2>
<p>The UTLS transport provides a hybrid transport, utilizing both the TLS and UX transports internally for actual connection establishment and message delivery.</p>
<p>On the client side, at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, the UTLS transport determines if the server socket can be reached by using the UX transport (i.e. if the server socket is located on the same OS instance, in the same network namespace). If not, UTLS will attempt to reach the server by means of the TLS transport.</p>
<p>For a particular UTLS connection, either TLS or UX is used (never both). XCM connections to a particular UTLS server socket may be a mix of the two different types.</p>
<p>For an UTLS server socket with the address <code>utls:&lt;ip&gt;:&lt;port&gt;</code>, two underlying addresses will be allocated; <code>tls:&lt;ip&gt;:&lt;port&gt;</code> and <code>ux:&lt;ip&gt;:&lt;port&gt;</code>.</p>
<p>In case DNS is used: <code>tls:&lt;hostname&gt;:&lt;port&gt;</code> and <code>ux:&lt;hostname&gt;:&lt;port&gt;</code>.</p>
<h3><a class="anchor" id="utls_attr"></a>
UTLS Socket Attributes</h3>
<p>UTLS sockets accept all the <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>, as well as the <a class="el" href="index.html#xcm_attr">Generic Attributes</a>. In case a UTLS connection is being established as a UX connection socket, all TLS attributes are ignored.</p>
<h3><a class="anchor" id="utls_limitations"></a>
UTLS Limitations</h3>
<p>A wildcard should never be used when creating a UTLS server socket.</p>
<p>If a DNS hostname is used in place of the IP address, both the client and server need employ DNS, and also agree upon which hostname to use (in case there are several pointing at the same IP address).</p>
<p>Failure to adhere to the above two rules will prevent a client from finding a local server. Such a client will instead establish a TLS connection to the server.</p>
<h2><a class="anchor" id="sctp_transport"></a>
SCTP Transport</h2>
<p>The SCTP transport uses the Stream Control Transmission Protocol (SCTP). SCTP provides a reliable, message-oriented service. In-order delivery is optional, but to adhere to XCM semantics (and for other reasons) XCM leaves SCTP in-order delivery enabled.</p>
<p>The SCTP transport utilizes the native Linux kernel's implementation of SCTP, via the BSD Socket API. The operating mode is such that there is a 1:1-mapping between an association and a socket (fd).</p>
<p>The SCTP transport supports IPv4 and IPv6.</p>
<p>To minimize latency, the SCTP transport disables the Nagle algorithm.</p>
<p>The SCTP transport has a maximum message size of 65535 bytes. This limit may change in future versions.</p>
<h2><a class="anchor" id="btcp_transport"></a>
BTCP Transport</h2>
<p>The BTCP transport provides a reliable two-way byte stream service over TCP.</p>
<p>Unlike the <a class="el" href="index.html#tcp_transport">TCP Transport</a>, BTCP doesn't use a framing header or anything else on the wire protocol level that is specific to XCM. In other words, it's a "raw" TCP connection.</p>
<p>Other than the above-mentioned differences, BTCP is identical to the <a class="el" href="index.html#tcp_transport">TCP Transport</a>, including supported <a class="el" href="index.html#dns_attr">DNS Socket Attributes</a> and <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a>.</p>
<h2><a class="anchor" id="btls_transport"></a>
BTLS Transport</h2>
<p>The BTLS transport provides a direct mapping to the Transport Layer Security (TLS) protocol over TCP. It provides a secure, private, two-way authenticated byte stream service.</p>
<p>BTLS has the same relationship to the <a class="el" href="index.html#tls_transport">TLS Transport</a> as the <a class="el" href="index.html#tcp_transport">TCP Transport</a> has to the <a class="el" href="index.html#tcp_transport">TCP Transport</a>.</p>
<p>BTLS doesn't add a framing header or any other XCM BTLS-level protocol artefacts on top of the TLS session. In other words, it's a "raw" TLS connection.</p>
<p>Other than providing a byte stream, it's identical to the <a class="el" href="index.html#tls_transport">TLS Transport</a>, including supported <a class="el" href="index.html#dns_attr">DNS Socket Attributes</a>, <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a> and <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>.</p>
<h1><a class="anchor" id="namespaces"></a>
Linux Network and IPC Namespaces</h1>
<p>Namespaces is a Linux kernel facility concept for creating multiple, independent namespaces for kernel resources of a certain kind.</p>
<p>Linux Network Namespaces will affect all transports, except the <a class="el" href="index.html#uxf_transport">UXF Transport</a>.</p>
<p>XCM has no explicit namespace support. Rather, the application is expected to use the Linux kernel facilities for this functionality (i.e. switch to the right namespace before <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> och <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>).</p>
<p>In case the system follows the iproute2 conventions in regards to network namespace naming, the TLS and UTLS transports support per-network namespace TLS certificates and private keys.</p>
<h1><a class="anchor" id="tracing"></a>
Tracing</h1>
<p>In case XCM is built with LTTng support, the XCM library will register two tracepoints: <code>com_ericsson_xcm:xcm_debug</code> and <code>com_ericsson_xcm:xcm_error</code>. The <code>xcm_debug</code> is verbose indeed, while messages on <code>xcm_error</code> are rare indeed. The latter is mostly due to the fact there are very few conditions that the library reliable can classify as errors, since many "errors" [e.g., connection refused] may well be the expected result).</p>
<p>If the XCM_DEBUG environment variable is set, the same trace messages that are routed via the LTTng tracepoints, are printed to stderr of the process linked to the library.</p>
<p>The tracepoint names and the format of the messages are subject to change, and not to be considered a part of the XCM API. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 30 2025 11:06:29 for Extensible Connection-oriented Messaging (XCM) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
