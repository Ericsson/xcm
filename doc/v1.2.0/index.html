<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extensible Connection-oriented Messaging (XCM): Extensible Connection-oriented Messaging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extensible Connection-oriented Messaging (XCM)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Extensible Connection-oriented Messaging </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#semantics">Overall Service Semantics</a><ul><li class="level2"><a href="#ordering">Ordering Guarantees</a></li>
<li class="level2"><a href="#flow_control">Flow Control</a></li>
</ul>
</li>
<li class="level1"><a href="#addressing">Addressing and Transport Selection</a><ul><li class="level2"><a href="#address_syntax">Address Syntax</a><ul><li class="level3"><a href="#dns">DNS Resolution</a></li>
<li class="level3"><a href="#ip_addr_format">IPv4 Address Format</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#dpd">Dead Peer Detection</a></li>
<li class="level1"><a href="#error_handling">Error Handling</a></li>
<li class="level1"><a href="#select">Event-driven Programming Support</a><ul><li class="level2"><a href="#select_variants">Supported I/O Multiplexing Facilities</a></li>
<li class="level2"><a href="#non_blocking_ops">Non-blocking Operation</a><ul><li class="level3"><a href="#non_blocking_connect">Non-blocking Connection Establishment</a></li>
<li class="level3"><a href="#non_blocking_send_receive">Non-blocking Send and Receive</a></li>
<li class="level3"><a href="#outstanding_tasks">Finishing Outstanding Tasks</a></li>
</ul>
</li>
<li class="level2"><a href="#might_block">Ready Status Semantics</a></li>
<li class="level2"><a href="#nb_examples">Non-blocking Example Sequences</a><ul><li class="level3"><a href="#nb_connect_and_send">Connect and Send Message</a></li>
<li class="level3"><a href="#nb_connect_explicit">Connect with Explicit Finish</a></li>
<li class="level3"><a href="#nb_immediate_connection_refused">Immediate Connection Refused</a></li>
<li class="level3"><a href="#nb_delayed_connection_refused">Delayed Connection Refused</a></li>
<li class="level3"><a href="#nb_flush_buffers_before_close">Buffer Flush Before Close</a></li>
<li class="level3"><a href="#nb_server_accept">Server Accept</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#attributes">Socket Attributes</a><ul><li class="level2"><a href="#attr_map">Attribute Maps</a></li>
<li class="level2"><a href="#xcm_attr">Generic Attributes</a><ul><li class="level3"><a href="#cnt_attr">Generic Message Counter Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#ctl">Control Interface</a><ul><li class="level2"><a href="#ctl_dir">Control UNIX Socket Directory</a></li>
<li class="level2"><a href="#ctl_errors">Control Interface Error Handling</a></li>
<li class="level2"><a href="#ctl_api">Control API</a></li>
<li class="level2"><a href="#ctl_shell">Command-line Control Program</a></li>
</ul>
</li>
<li class="level1"><a href="#thread_safety">Thread Safety</a></li>
<li class="level1"><a href="#fork">Multi-processing and Fork</a></li>
<li class="level1"><a href="#transports">Transports</a><ul><li class="level2"><a href="#ux_transport">UX Transport</a><ul><li class="level3"><a href="#ux_naming">UX Namespace</a></li>
</ul>
</li>
<li class="level2"><a href="#uxf_transport">UXF Transport</a></li>
<li class="level2"><a href="#tcp_transport">TCP Transport</a><ul><li class="level3"><a href="#tcp_attr">TCP Socket Attributes</a></li>
</ul>
</li>
<li class="level2"><a href="#tls_transport">TLS Transport</a><ul><li class="level3"><a href="#tls_certificates">TLS Certificate and Key Storage</a><ul><li class="level4"><a href="#per_ns_certs">Per-network Namespace Certificates</a></li>
<li class="level4"><a href="#cert_update">Runtime Certificate File Updates</a></li>
</ul>
</li>
<li class="level3"><a href="#tls_attr">TLS Socket Attributes</a></li>
</ul>
</li>
<li class="level2"><a href="#utls_transport">UTLS Transport</a><ul><li class="level3"><a href="#utls_limitations">UTLS Limitations</a></li>
</ul>
</li>
<li class="level2"><a href="#sctp_transport">SCTP Transport</a></li>
</ul>
</li>
<li class="level1"><a href="#namespaces">Linux Network and IPC Namespaces</a></li>
<li class="level1"><a href="#limitations">Limitations</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>This is the documentation for the Extensible Connection-oriented Messaging (XCM) programming APIs.</p>
<p>XCM consists the core API in <a class="el" href="xcm_8h.html" title="This file contains the core Extensible Connection-oriented Messaging (XCM) API.">xcm.h</a>, an address helper library API in <a class="el" href="xcm__addr_8h.html" title="This is an API for building and parsing Connection-oriented Messaging (XCM) addresses.">xcm_addr.h</a>, and the attribute APIs in <a class="el" href="xcm__attr_8h.html" title="This file contains the XCM attribute access API. See Socket Attributes for an overview.">xcm_attr.h</a> and <a class="el" href="xcm__attr__map_8h.html" title="This file contains the XCM attribute map API.">xcm_attr_map.h</a>. Obsolete, but still present, functions are available in <a class="el" href="xcm__compat_8h.html" title="This file contains obsolete parts of the XCM core API.">xcm_compat.h</a></p>
<dl class="section author"><dt>Author</dt><dd>Mattias RÃ¶nnblom </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.16 [API] </dd>
<dd>
1.2.0 [Implementation]</dd></dl>
<p>The low API/ABI version number is purely a result of all XCM releases being backward compatible, and thus left the major version at 0. It's not to be taken as a sign of immaturity. The API and its implementation have been stable for years.</p>
<h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>XCM provides a connection-oriented, reliable messaging service with in-order delivery. The design goal is to allow for a straight forward mapping to TCP and TLS, but also supporting efficient inter-process commmunication (IPC) mechanisms for local communication.</p>
<p>XCM reuses much of the terminology of the BSD Sockets API. Unlike the BSD Socket API, XCM has uniform semantics across all underlying transports.</p>
<h1><a class="anchor" id="semantics"></a>
Overall Service Semantics</h1>
<p>XCM has a client-server model. A server creates a server socket (with <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>) bound to a specific address (in case of TCP or TLS, a TCP port on a particular IP interface), after which clients may initiate connections to the server. On a successful attempt, two connection sockets will be created; one on the server side (returned from <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>), and one of the client side (returned from <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>). Thus, a server serving multiple clients will have multiple sockets; one server socket and N connection sockets, one each for every client. A client will typically have one connection socket for each server it is connected to.</p>
<p>Messages are always sent and received on a particular connection socket (and never on a server socket).</p>
<h2><a class="anchor" id="ordering"></a>
Ordering Guarantees</h2>
<p>In-order delivery - that messages arrive at the recipient in the same order they were sent by the sender side - is guaranteed, but only for messages sent on the same connection.</p>
<h2><a class="anchor" id="flow_control"></a>
Flow Control</h2>
<p>XCM transports support flow control. Thus, if the sender message rate or bandwidth is higher than the network or the receiver can handle on a particular connection, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> in the sender process will eventually block (or return an error EAGAIN, if in non-blocking mode). Unless XCM is used for bulk data transfer (as oppose to signaling traffic), <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> blocking because of slow network or a slow receiver should be rare indeed in practice. TCP, TLS, and UNIX domain socket transports all have large enough windows and socket buffers to allow a large amount of outstanding data.</p>
<h1><a class="anchor" id="addressing"></a>
Addressing and Transport Selection</h1>
<p>In XCM, the application is in control of which transport will be used, with the address supplied to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> including both the transport name and the transport address.</p>
<p>However, there is nothing preventing a XCM transport to use a more an abstract addressing format, and internally include multiple "physical" IPC transport options. This model is used by the <a class="el" href="index.html#utls_transport">UTLS Transport</a>.</p>
<h2><a class="anchor" id="address_syntax"></a>
Address Syntax</h2>
<p>Addresses are represented as strings with the following general syntax: <code>&lt;transport-name&gt;:&lt;transport-address&gt;</code></p>
<p>For the UX UNIX Domain Socket transport, the addresses has this more specific form: <br  />
</p><div class="fragment"><div class="line">ux:&lt;UNIX domain socket name&gt; </div>
</div><!-- fragment --><p>The addresses of the UXF UNIX Domain Socket transport variant have the following format: <br  />
</p><div class="fragment"><div class="line">uxf:&lt;file system path&gt; </div>
</div><!-- fragment --><p>For the TCP, TLS, UTLS and SCTP transports the syntax is: <br  />
</p><div class="fragment"><div class="line">tcp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">tls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">utls:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
<div class="line">sctp:(&lt;DNS domain name&gt;|&lt;IPv4 address&gt;|[&lt;IPv6 address&gt;]|[*]|*):&lt;port&gt;</div>
</div><!-- fragment --><p>'*' is a shorthand for '0.0.0.0' (i.e. bind to all IPv4 interfaces). '[*]' is the IPv6 equivalent, creating a server socket accepting connections on all IPv4 and IPv6 addresses.</p>
<p>Some examples addresses: </p><div class="fragment"><div class="line">tcp:*:4711</div>
<div class="line">tls:192.168.1.42:4711</div>
<div class="line">tcp:[::1]:99</div>
<div class="line">tcp:[*]:4711</div>
<div class="line">tls:service:4711</div>
<div class="line">sctp:service.company.com:42</div>
</div><!-- fragment --><p>For TCP, TLS, UTLS and SCTP server socket addresses, the port can be set to 0, in which case XCM (or rather, the Linux kernel) will allocate a free TCP port from the local port range.</p>
<h3><a class="anchor" id="dns"></a>
DNS Resolution</h3>
<p>For transports allowing a DNS domain name as a part of the address, the transport will attempt resoÄºv the name to an IP address. A DNS domain name may resolv to zero or more IPv4 addresses and/or zero or more IPv6 addresses. XCM relies on the operating system to prioritize between IPv4 and IPv6.</p>
<h3><a class="anchor" id="ip_addr_format"></a>
IPv4 Address Format</h3>
<p>XCM accepts IPv4 addresses in the dotted-decimal format </p><div class="fragment"><div class="line">130.236.254.2</div>
</div><!-- fragment --><p>XCM allows only complete addresses with three '.', and not the archaic, classful, forms, where some bytes where left out, and thus the address contained fewer separators.</p>
<h1><a class="anchor" id="dpd"></a>
Dead Peer Detection</h1>
<p>XCM transports attempt to detect a number of conditions which can lead to lost connectivity, and does so even on idle connections.</p>
<p>If the remote end closes the connection, the local <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return 0. If the process on the remote end crashed, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return -1 and set errno ECONNRESET. If network connectivity to the remote end is lost, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return -1 and errno will be set to ETIMEDOUT.</p>
<h1><a class="anchor" id="error_handling"></a>
Error Handling</h1>
<p>In general, XCM follow the UNIX system API tradition when it comes to error handling. Where possible, errors are signaled to the application by using unused parts of the value range of the function return type. For functions returning signed integer types, this means the value of -1 (in case -1 is not a valid return value). For functions returning pointers, NULL is used to signal that an error has occurred. For functions where neither -1 or NULL can be used, or where the function does not return anything (side-effect only functions), an 'int' is used as the return type, and is used purely for the purpose to signal success (value 0), or an error (-1) to the application.</p>
<p>The actual error code is stored in the thread-local errno variable. The error codes are those from the fixed set of errno values defined by POSIX, found in errno.h. Standard functions such as perror() and strerror() may be used to turn the code into a human-readable string.</p>
<p>In non-blocking operation, given the fact the actual transmission might be defered (and the message buffered in the XCM layer), and that message receive processing might happen before the application has called receive, the error being signaled at the point of a certain XCM call might not be a direct result of the requested operation, but rather an error discovered previously.</p>
<p>The documentation for <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> includes a list of generic error codes, applicable <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<p>Also, for errors resulting in an unusable connection, repeated calls will produce the same errno.</p>
<h1><a class="anchor" id="select"></a>
Event-driven Programming Support</h1>
<p>In UNIX-style event-driven programming, a single application thread handles multiple clients (and thus multiple XCM connection sockets) and the task of accepting new clients on the XCM server socket concurrently (although not in parallel). To wait for events from multiple sources, an I/O multiplexing facility such as select(2), poll(2) or epoll(2) is used.</p>
<p>Each XCM socket is represented by a single fd, retrieved with <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a>. The fd number and underlying file object is stable across the life-time of the socket.</p>
<p>On BSD Sockets, the socket fd being readable means it's likely that the application can successfully read data from the socket. Similarily, a fd marked writable by, for example, poll() means that the application is likely to be able to write data to the BSD Sockets fd. For an application using XCM going into select(), it must <em>always</em> wait for all the fds its XCM sockets to become readable (e.g. being in the <code>readfds</code> in the select() call), regardless what are their target conditions. Thus, even if the application is waiting for an opportunity to try to send a message on a XCM socket, or it doesn't want to do anything with the socket, it must wait for the socket <em>fd</em> to become readable. Not wanting to do nothing here means that the application has the <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> condition set to 0, and is neither interested in waiting to call <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>, nor <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> on the socket. An application may never leave a XCM socket unattended in the sense its fd is not in the set of fds passed to select() and/or <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> are not called.</p>
<h2><a class="anchor" id="select_variants"></a>
Supported I/O Multiplexing Facilities</h2>
<p>XCM is oblivious to what I/O multiplexing mechanism employed by the application. It may call select(), poll() or epoll_wait() directly, or make use of any of the many available event loop libraries (such as libevent). For simplicity, select() is used in this documentation to denote the whole family of Linux I/O multiplexing facilities.</p>
<h2><a class="anchor" id="non_blocking_ops"></a>
Non-blocking Operation</h2>
<p>An event-driven application needs to set the XCM sockets it handles into non-blocking mode, by calling <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a>, setting the "xcm.blocking" socket attribute, or using the XCM_NONBLOCK flag in <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>.</p>
<p>For XCM sockets in non-blocking mode, all potentially blocking API calls related to XCM connections - <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> - finish immediately.</p>
<p>For <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, XCM signaling success means that the XCM layer has accepted the request. It may or may not have completed the operation.</p>
<h3><a class="anchor" id="non_blocking_connect"></a>
Non-blocking Connection Establishment</h3>
<p>In case the <a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a> flag is set in the <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> call, or in case the a XCM server socket is in non-blocking mode at the time of a <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> call, the newly created XCM connection returned to the application may be in a semi-operational state, with some internal processing and/or signaling with the remote peer still required before actual message transmission and reception may occur.</p>
<p>The application may attempt to send or receive messages on such semi-operational connections.</p>
<p>There are ways for an application to determine when connection establishment or the task of accepting a new client have completed. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for more information.</p>
<h3><a class="anchor" id="non_blocking_send_receive"></a>
Non-blocking Send and Receive</h3>
<p>To receive a message on a XCM connection socket in non-blocking mode, the application may need to wait for the right conditions to arise (i.e. a message being available). The application needs to inform the socket that it wants to receive by calling <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> with the <code>XCM_SO_RECEIVABLE</code> bit in the <code>condition</code> bit mask set. It will pass the fd it received from <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> into select(), asking to get notified when the fd becomes readable. When select() marks the socket fd as readable, the application should issue <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> to attempt to retrieve a message.</p>
<p><a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> may also called on speculation, prior to any select() call, to poll the socket for incoming messages.</p>
<p>A XCM connection socket may have a number of messages buffered, and applications should generally, for optimal performance, repeat <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> until it returns an error, and errno is set to EAGAIN.</p>
<p>Similarly to receiving a message, an application may set the <code>XCM_SO_SENDABLE</code> bit in the <code>condition</code> bit mask, if it wants to wait for a socket state where it's likely it can successfully send a message. When select() marks the socket fd as <em>readable</em>, the application should attempt to send a message.</p>
<p>Just like with <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>, it may also choose to issue a <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> call on speculation (i.e. without going into select()), which is often a good idea for performance reasons.</p>
<p>For send operations on non-blocking connection sockets, XCM may buffer whole or part of the message before transmission to the lower layer. This may be due to socket output buffer underrun, or the need for some in-band signaling, like cryptographic key exchange, to happen before the transmission of the complete message may finish. The XCM layer will (re-)attempt to hand the message over to the lower layer at a future call to <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, or <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<p>For applications wishing to determine when all buffered messages have successfully be deliver to the lower layer, they may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so. Normally, applications aren't expected to require this kind of control. Please also note that the fact a message has left the XCM layer doesn't necessarily mean it has successfully been delivered to the recipient.</p>
<h3><a class="anchor" id="outstanding_tasks"></a>
Finishing Outstanding Tasks</h3>
<p><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> may all leave the socket in a state where work is initiated, but not completed. In addition, the socket may have pending internal tasks, such flushing the output buffer into the TCP/IP stack, processing XCM control interface messages, or finishing the TLS hand shake procedure.</p>
<p>After waking up from a select() call, where a particular XCM non-blocking socket's fd is marked readable, the application must, if no <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> calls are to be made, call <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>. This is to allow the socket to finish any outstanding tasks, even in the case the application has no immediate plans for the socket.</p>
<p>Prior to changing a socket from non-blocking to blocking mode, any outstanding tasks should be finished, or otherwise the switch might cause <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> to return -1 and set errno to EAGAIN.</p>
<h2><a class="anchor" id="might_block"></a>
Ready Status Semantics</h2>
<p>For example, if a server socket's desired condition has been set (with <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a>) to <code>XCM_SO_ACCEPTABLE</code>, and the application wakes up from select() with the socket's fd marked readable, a call to <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> may still not produce a new connection socket.</p>
<p>The same holds true when reaching <code>XCM_SO_RECEIVABLE</code> and a <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> call is made, and <code>XCM_SO_SENDABLE</code> and calls to <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>.</p>
<h2><a class="anchor" id="nb_examples"></a>
Non-blocking Example Sequences</h2>
<h3><a class="anchor" id="nb_connect_and_send"></a>
Connect and Send Message</h3>
<p>In this example, the application connects and tries to send a message, before knowing if the connection is actually established. This may fail (for example, in case TCP and/or TLS-level connection establishement has not yet been completed), in which case the application will fall back and wait with the use of <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a>, <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> and select().</p>
<div class="plantumlgraph">
<img src="nb_connect_and_send.png" />
</div>
<h3><a class="anchor" id="nb_connect_explicit"></a>
Connect with Explicit Finish</h3>
<p>In case the application wants to know when the connection establishment has finished, it may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so, like in the below example sequence.</p>
<div class="plantumlgraph">
<img src="nb_connect_explicit.png" />
</div>
<h3><a class="anchor" id="nb_immediate_connection_refused"></a>
Immediate Connection Refused</h3>
<p>While connecting to a server socket, the client's connection attempt may be refused immediately.</p>
<div class="plantumlgraph">
<img src="nb_immediate_connection_refused.png" />
</div>
<h3><a class="anchor" id="nb_delayed_connection_refused"></a>
Delayed Connection Refused</h3>
<p>In many cases, the application is handed a connection socket before the connection establishment is completed. Any errors occuring during this process is handed over to the application at the next XCM call; would it be <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> or <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<div class="plantumlgraph">
<img src="nb_delayed_connection_refused.png" />
</div>
<h3><a class="anchor" id="nb_flush_buffers_before_close"></a>
Buffer Flush Before Close</h3>
<p>In this example the application flushes any internal XCM buffers before shutting down the connection, to ensure that any buffered messages are delivered to the lower layer.</p>
<div class="plantumlgraph">
<img src="nb_flush_buffers_before_close.png" />
</div>
<h3><a class="anchor" id="nb_server_accept"></a>
Server Accept</h3>
<p>In this sequence, a server accepts a new connection, and continues to attempt to receive a message on this connection, while still, concurrently, is ready to accept more clients on the server socket.</p>
<div class="plantumlgraph">
<img src="server_accept.png" />
</div>
<h1><a class="anchor" id="attributes"></a>
Socket Attributes</h1>
<p>Tied to an XCM server or connection socket is a set of key-value pairs known as attributes. Which attributes are available varies across different transports, and different socket types.</p>
<p>An attribute's name is a string, and follows a hierarchical naming schema. For example, all generic XCM attributes, available in all transports, have the prefix "xcm.". Transport-specific attributes are prefixed with the transport or protocol name (e.g. "tcp." for TCP-specific attributes applicable to the TLS and TCP transports).</p>
<p>An attribute may be read-only, write-only or available both for reading and writing. This is referred to as the attribute's mode. The mode may vary across the lifetime of the socket. For example, an attribute may be writable at the time of the <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> call, and read-only thereafter.</p>
<p>The attribute value is coded in the native C data type and byte order. Strings are NUL-terminated, and the NUL character is included in the length of the attribute. There are four value types; a boolean type, a 64-bit signed integer type, a string type and a type for arbitrary binary data. See <a class="el" href="xcm__attr__types_8h.html" title="This file contains type definitions for the XCM attribute access API.">xcm_attr_types.h</a> for details.</p>
<p>The attribute access API is in <a class="el" href="xcm__attr_8h.html" title="This file contains the XCM attribute access API. See Socket Attributes for an overview.">xcm_attr.h</a>.</p>
<p>Retrieving an integer attribute's value may look like this: </p><div class="fragment"><div class="line">int64_t rtt;</div>
<div class="line"><a class="code hl_function" href="xcm__attr_8h.html#accaa82dfb750ba09b9d999a8ce59d95f">xcm_attr_get</a>(tcp_conn_socket, <span class="stringliteral">&quot;tcp.rtt&quot;</span>, NULL, &amp;rtt, <span class="keyword">sizeof</span>(rtt));</div>
<div class="line">printf(<span class="stringliteral">&quot;Current TCP round-trip time estimate is %ld us.&quot;</span>, rtt);</div>
<div class="ttc" id="axcm__attr_8h_html_accaa82dfb750ba09b9d999a8ce59d95f"><div class="ttname"><a href="xcm__attr_8h.html#accaa82dfb750ba09b9d999a8ce59d95f">xcm_attr_get</a></div><div class="ttdeci">int xcm_attr_get(struct xcm_socket *socket, const char *name, enum xcm_attr_type *type, void *value, size_t capacity)</div></div>
</div><!-- fragment --><p>Changing an integer attribyte value may be done in the following manner: </p><div class="fragment"><div class="line">int64_t interval = 10;</div>
<div class="line"><a class="code hl_function" href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set</a>(tcp_conn_socket, <span class="stringliteral">&quot;tcp.keepalive_interval&quot;</span>, <a class="code hl_enumvalue" href="xcm__attr__types_8h.html#abad988495911d3fa382baa0028da7734a38a9645de8fc284db445aeea95fe5189">xcm_attr_type_int64</a>, &amp;interval, <span class="keyword">sizeof</span>(interval));</div>
<div class="ttc" id="axcm__attr_8h_html_a182c1e6606a5481e6d10693a7b2db839"><div class="ttname"><a href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set</a></div><div class="ttdeci">int xcm_attr_set(struct xcm_socket *socket, const char *name, enum xcm_attr_type type, const void *value, size_t len)</div></div>
<div class="ttc" id="axcm__attr__types_8h_html_abad988495911d3fa382baa0028da7734a38a9645de8fc284db445aeea95fe5189"><div class="ttname"><a href="xcm__attr__types_8h.html#abad988495911d3fa382baa0028da7734a38a9645de8fc284db445aeea95fe5189">xcm_attr_type_int64</a></div><div class="ttdeci">@ xcm_attr_type_int64</div><div class="ttdef"><b>Definition</b> xcm_attr_types.h:22</div></div>
</div><!-- fragment --><p>Both of these examples are missing error handling.</p>
<h2><a class="anchor" id="attr_map"></a>
Attribute Maps</h2>
<p>XCM allows supplying a set of writable attributes at the time of socket creation, by using the <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a>, <a class="el" href="xcm_8h.html#a6b334574c9e1b15af4c0350d8b7cf9ad">xcm_server_a()</a>, or <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> functions.</p>
<p>The attribute sets are represented by the <code>xcm_attr_map</code> type in <a class="el" href="xcm__attr__map_8h.html" title="This file contains the XCM attribute map API.">xcm_attr_map.h</a>.</p>
<p>An example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>xcm_attr_map *attrs = <a class="code hl_function" href="xcm__attr__map_8h.html#a128624b0a4d5ffe8defb482c63f6396e">xcm_attr_map_create</a>();</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#ad618223af0a37c2c55814f84e8d27637">xcm_attr_map_add_bool</a>(attrs, <span class="stringliteral">&quot;xcm.blocking&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#a3f1421bc7c615faa5370158f08b77644">xcm_attr_map_add_str</a>(attrs, <span class="stringliteral">&quot;xcm.local_addr&quot;</span>, <span class="stringliteral">&quot;tls:192.168.1.42:0&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#a621c6f6e5d062f1d28ebbc9cc79be730">xcm_attr_map_add_int64</a>(attrs, <span class="stringliteral">&quot;tcp.keepalive_interval&quot;</span>, 10);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> rc = <a class="code hl_function" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a</a>(<span class="stringliteral">&quot;tls:192.168.1.99:4711&quot;</span>, attrs);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="xcm__attr__map_8h.html#aeafbfc82e1229a77233dd7811e175fb5">xcm_attr_map_destroy</a>(attrs);</div>
<div class="ttc" id="axcm_8h_html_ae8e67bc6e21a33371bd273e089d6d741"><div class="ttname"><a href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a</a></div><div class="ttdeci">struct xcm_socket * xcm_connect_a(const char *remote_addr, const struct xcm_attr_map *attrs)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_a128624b0a4d5ffe8defb482c63f6396e"><div class="ttname"><a href="xcm__attr__map_8h.html#a128624b0a4d5ffe8defb482c63f6396e">xcm_attr_map_create</a></div><div class="ttdeci">struct xcm_attr_map * xcm_attr_map_create(void)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_a3f1421bc7c615faa5370158f08b77644"><div class="ttname"><a href="xcm__attr__map_8h.html#a3f1421bc7c615faa5370158f08b77644">xcm_attr_map_add_str</a></div><div class="ttdeci">void xcm_attr_map_add_str(struct xcm_attr_map *attr_map, const char *attr_name, const char *attr_value)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_a621c6f6e5d062f1d28ebbc9cc79be730"><div class="ttname"><a href="xcm__attr__map_8h.html#a621c6f6e5d062f1d28ebbc9cc79be730">xcm_attr_map_add_int64</a></div><div class="ttdeci">void xcm_attr_map_add_int64(struct xcm_attr_map *attr_map, const char *attr_name, int64_t attr_value)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_ad618223af0a37c2c55814f84e8d27637"><div class="ttname"><a href="xcm__attr__map_8h.html#ad618223af0a37c2c55814f84e8d27637">xcm_attr_map_add_bool</a></div><div class="ttdeci">void xcm_attr_map_add_bool(struct xcm_attr_map *attr_map, const char *attr_name, bool attr_value)</div></div>
<div class="ttc" id="axcm__attr__map_8h_html_aeafbfc82e1229a77233dd7811e175fb5"><div class="ttname"><a href="xcm__attr__map_8h.html#aeafbfc82e1229a77233dd7811e175fb5">xcm_attr_map_destroy</a></div><div class="ttdeci">void xcm_attr_map_destroy(struct xcm_attr_map *attr_map)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="xcm_attr"></a>
Generic Attributes</h2>
<p>These attributes are expected to be found on XCM sockets regardless of transport type.</p>
<p>For TCP transport-specific attributes, see <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a>, and for TLS, see <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.type   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The socket type: "server" or "connection".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.transport   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The transport type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.local_addr   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The local address of a socket. Writable only if supplied to <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.blocking   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">See <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> and <a class="el" href="xcm_8h.html#a6cfdb3e1a859549d686c93b32c6a6818">xcm_is_blocking()</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.remote_addr   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">See <a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr()</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.max_msg_size   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The maximum size of any message transported by this connection.   </td></tr>
</table>
<h3><a class="anchor" id="cnt_attr"></a>
Generic Message Counter Attributes</h3>
<p>XCM has a set of generic message counters, which keeps track of the number of messages crossing a certain boundary for a particular connection, and a sum of their size.</p>
<p>Some of the message and byte counter attributes use the concept of a "lower layer". What this means depends on the transport. For the UX And TCP transports, it is the Linux kernel. For example, for TCP, if the xcm.to_lower_msgs is incremented, it means that XCM has successfully sent the complete message to the kernel's networking stack for further processing. It does not means it has reached the receiving process. It may have, but it also may be sitting on the local or remote socket buffer, on a NIC queue, or be in-transmit in the network. For TLS, the lower layer is OpenSSL.</p>
<p>All the "xcm.*_bytes" counters count the length of the XCM message payload (as in the length field in <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>), and thus does not include any underlying headers.</p>
<p>The message counters only count messages succesfully sent and/or received.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_app_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages sent from the application and accepted into XCM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.from_app_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The sum of the size of all messages counted by xcm.from_app_msgs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.to_app_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages delivered from XCM to the application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_app_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The sum of the size of all messages counter by xcm.to_app_msgs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.from_lower_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages received by XCM from the lower layer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.from_lower_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The sum of the size of all messages counted by xcm.from_lower_msgs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">xcm.to_lower_msgs   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">Messages successfully sent by XCM into the lower layer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">xcm.to_lower_bytes   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The sum of the size of all messages counted by xcm.to_lower_msgs.   </td></tr>
</table>
<h1><a class="anchor" id="ctl"></a>
Control Interface</h1>
<p>XCM includes a control interface, which allows iteration over the OS instance's XCM server and connection sockets (for processes with the appropriate permissions), and access to their attributes (see <a class="el" href="index.html#attributes">Socket Attributes</a>).</p>
<p>The control interface is optional by means of build-time configuration.</p>
<p>For each XCM server or connection socket, there is a corresponding UNIX domain socket which is used for control signaling (i.e. state retrieval).</p>
<h2><a class="anchor" id="ctl_dir"></a>
Control UNIX Socket Directory</h2>
<p>By default, the control interface's UNIX domain sockets are stored in the <code>/run/xcm/ctl</code> directory.</p>
<p>This directory needs to be created prior to running any XCM applications (for the control interface to worker properly) and should be writable for all XCM users.</p>
<p>A particular process using XCM may be configured to use a non-default directory for storing the UNIX domain sockets used for the control interface by means of setting the <code>XCM_CTL</code> variable. Please note that using this setting will cause the XCM connections to be not visible globally on the OS instance (unless all other XCM-using processes also are using this non-default directory).</p>
<h2><a class="anchor" id="ctl_errors"></a>
Control Interface Error Handling</h2>
<p>Generally, since the application is left unaware (from an API perspective) of the existence of the control interface, errors are not reported up to the application. They are however logged.</p>
<p>Application threads owning XCM sockets, but which are busy with non-XCM processing for a long duration of time, or otherwise are leaving their XCM sockets unattended to (in violation of XCM API contract), will not respond on the control interface's UNIX domain sockets (corresponding to their XCM sockets). Only the presence of these sockets may be detected, but their state cannot be retrieved.</p>
<h2><a class="anchor" id="ctl_api"></a>
Control API</h2>
<p>Internally, the XCM implementation has control interface client library, but this library's API is not public at this point.</p>
<h2><a class="anchor" id="ctl_shell"></a>
Command-line Control Program</h2>
<p>XCM includes a command-line program <code>xcmctl</code> which uses the <a class="el" href="index.html#ctl_api">Control API</a> to iterate of the system's current XCM sockets, and allow access (primarily for debugging purposes) to the sockets' attributes.</p>
<h1><a class="anchor" id="thread_safety"></a>
Thread Safety</h1>
<p>Unlike BSD sockets, a XCM socket may not be shared among different threads without synchronization external to XCM. With proper external serialization, a socket may be shared by different threads in the same process, although it might provide difficult in practice since a thread in a blocking XCM function will continue to hold the lock, and thus preventing other threads from accessing the socket at all.</p>
<p>For non-blocking sockets, threads sharing a socket need to agree on what is the appropriate socket <code>condition</code> to wait for. When this condition is met, all threads are woken up, returning from select().</p>
<p>It is safe to "give away" a XCM socket from one thread to another, provided the appropriate memory fences are used.</p>
<p>These limitations (compared to BSD Sockets) are in place to allow socket state outside the kernel (which is required for TCP framing and TLS).</p>
<h1><a class="anchor" id="fork"></a>
Multi-processing and Fork</h1>
<p>Sharing a XCM socket between threads in different processes is not possible.</p>
<p>After a fork() call, either of the two process (the parent, or the child) must be designated the owner of every XCM socket the parent owned.</p>
<p>The owner may continue to use the XCM socket normally.</p>
<p>The non-owner may not call any other XCM API call than <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a>, which frees local memory tied to this socket in the non-owner's process address space, without impacting the connection state in the owner process.</p>
<h1><a class="anchor" id="transports"></a>
Transports</h1>
<p>The core XCM API functions are oblivious to the transports used. However, the support for building, and parsing addresses are available only for a set of pre-defined set of transports. There is nothing preventing <a class="el" href="xcm__addr_8h.html" title="This is an API for building and parsing Connection-oriented Messaging (XCM) addresses.">xcm_addr.h</a> from being extended, and also nothing prevents an alternative XCM implementation to include more transports without extending the address helper API.</p>
<h2><a class="anchor" id="ux_transport"></a>
UX Transport</h2>
<p>The UX transport uses UNIX Domain (AF_UNIX, also known as AF_LOCAL) Sockets.</p>
<p>UX sockets may only be used with the same OS instance (or, more specifically, between processes in the same Linux kernel network namespace).</p>
<p>UNIX Domain Sockets comes in a number of flavors, and XCM uses the SOCK_SEQPACKET variety. SOCK_SEQPACKET sockets are connection-oriented, preserves message boundaries and delivers messages in the same order they were sent; perfectly matching XCM semantics and provides for an near-trivial mapping.</p>
<p>UX is the most efficient of the XCM transports.</p>
<h3><a class="anchor" id="ux_naming"></a>
UX Namespace</h3>
<p>The standard UNIX Domain Sockets as defined by POSIX uses the file system as its namespace, with the sockets also being files. However, for simplicity and to avoid situations where stale socket files (originating from crashed processes) causing problems, the UX transport uses a Linux-specific extension, allowing a private UNIX Domain Socket namespace. This is known as the abstract namespace (see the unix(7) man page for details). With the abstract namespace, server socket address allocation has the same life time as TCP ports (i.e. if the process dies, the address is free'd).</p>
<p>The UX transport enables the SO_PASSCRED BSD socket option, to give the remote peer a name (which UNIX domain connection socket doesn't have by default). This is for debugging and observability purposes. Without a remote peer name, in server processes with multiple incoming connections to the same server socket, it's difficult to say which of the server-side connection sockets goes to which remote peer. The kernel-generated, unique, name is an integer in the form "%05x" (printf format). Applications using hardcoded UX addresses should avoid such names by, for example, using a prefix.</p>
<p>The <a class="el" href="index.html#utls_transport">UTLS Transport</a> also indirectly uses the UX namespace, so care should be taken to avoid any clashes between UX and UTLS sockets in the same network namespace.</p>
<h2><a class="anchor" id="uxf_transport"></a>
UXF Transport</h2>
<p>The UXF transport is identical to the UX transport, only it uses the standard POSIX naming mechanism. The name of a server socket is a file system path, and the socket is also a file.</p>
<p>The UXF sockets resides in a file system namespace, as opposed to UX sockets, which live in a network namespace.</p>
<p>Upon <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a>, the socket will be closed and the file removed. If an application crashes or otherwise fails to run <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a>, it will leave a file in the file system pointing toward a non-existing socket. This file will prevent the creation another server socket with the same name.</p>
<h2><a class="anchor" id="tcp_transport"></a>
TCP Transport</h2>
<p>The TCP transport uses the Transmission Control Protocol (TCP), by means of the BSD Sockets API.</p>
<p>TCP is a byte-stream service, but the XCM TCP transport adds framing on top of the stream. A single-field 32-bit header containing the message length in network byte order is added to every message.</p>
<p>TCP uses TCP Keepalive to detect lost network connectivity between the peers.</p>
<p>The TCP transport supports IPv4 and IPv6.</p>
<p>Since XCM is designed for signaling traffic, the TCP transport disables the Nagle algorithm of TCP to avoid its excessive latency.</p>
<h3><a class="anchor" id="tcp_attr"></a>
TCP Socket Attributes</h3>
<p>The read-only TCP attributes are retrieved from the kernel (struct tcp_info in linux/tcp.h).</p>
<p>The read-write attributes are mapped directly to setsockopt() calls.</p>
<p>See the tcp(7) manual page for a more detailed description of these attributes. The struct retrieved with <code>TCP_INFO</code> is the basis for the read-only attributes. The read-write attributes are mapped to <code>TCP_KEEP*</code> and <code>TCP_USER_TIMEOUT</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.rtt   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The current TCP round-trip estimate (in us).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.total_retrans   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The total number of retransmitted TCP segments.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.segs_in   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The total number of segments received.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.segs_out   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The total number of segments sent.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.keepalive   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">Controls if TCP keepalive is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.keepalive_time   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) before the first keepalive probe is sent on an idle connection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.keepalive_interval   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) between keepalive probes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tcp.keepalive_count   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The number of keepalive probes sent before the connection is dropped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tcp.user_timeout   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The time (in s) before a connection is dropped due to unacknowledged data.   </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd><code>tcp.segs_in</code> and <code>tcp.segs_out</code> are only present when running XCM on Linux kernel 4.2 or later.</dd></dl>
<h2><a class="anchor" id="tls_transport"></a>
TLS Transport</h2>
<p>The TLS transport uses TLS to provide a secure, private, two-way authenticated transport.</p>
<p>TLS is a byte-stream service, but the XCM TLS transport adds framing in the same manner as does the XCM TCP transport.</p>
<p>The TLS transport supports IPv4 and IPv6.</p>
<p>The TLS transport disables the Nagle algorithm of TCP.</p>
<h3><a class="anchor" id="tls_certificates"></a>
TLS Certificate and Key Storage</h3>
<p>The TLS transport reads the leaf certificate and its private key, from the file system, as well as a file containing all trusted CA certificates. Default paths are configured at build-time.</p>
<p><a class="el" href="index.html#tls_attr">TLS Socket Attributes</a> may be used to override one or more of the default paths, on a per-socket basis. Paths set on server sockets are inherited by its connection sockets, but may in turn be overriden at the time of a <a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a()</a> call, using the proper attributes.</p>
<p>The default paths may also be overriden on a per-process basis by means of a UNIX environment variable. The current value of <code>XCM_TLS_CERT</code> (at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>) determines the certificate directory used for that connection.</p>
<h4><a class="anchor" id="per_ns_certs"></a>
Per-network Namespace Certificates</h4>
<p>The TLS transport will, at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> or <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>, look up the process' current network namespace, unless that file's path was given as a <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>. If the namespace is given a name per the iproute2 convention, XCM will retrieve this name and use it in the certificate and key lookup.</p>
<p>In case the certificate, key and trusted CA files are configured using <a class="el" href="index.html#tls_attr">TLS Socket Attributes</a>, no network namespace lookup will be performed.</p>
<p>In the certificate directory (either the compile-time default, or the directory specified with <code>XCM_TLS_CERT</code>), the TLS transport expects the files to follow the following naming conventions (where &lt;ns&gt; is the namespace): </p><div class="fragment"><div class="line">cert_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The private key is stored in: </p><div class="fragment"><div class="line">key_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>The trusted CA certificates are stored in: </p><div class="fragment"><div class="line">tc_&lt;ns&gt;.pem</div>
</div><!-- fragment --><p>For the default namespace (or any other network namespace not named according to iproute2 standards), the certificate need to be stored in a file "cert.pem", the private key in "key.pem" and the trusted CA certificates in "tc.pem".</p>
<p>In case the certificate, key or trusted CAs files are not in place (for a particular namespace), a <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> call will return an error and set errno to EPROTO. The application may choose to retry at a later time.</p>
<h4><a class="anchor" id="cert_update"></a>
Runtime Certificate File Updates</h4>
<p>In case a certificate, private key, or trusted CAs file is modified, the new version of the file(s) will be used by new connections. Such a change does not affect already-established connections. The TLS transport works with differences between set of files, and thus the new generation of files need not nesserarily be newer (as in having a more recent file system mtime).</p>
<p>The certificate, key and trusted CA certificates should be updated in an atomic manner, or XCM may end up using the certificate file from one generation of files and the key file from another, for example.</p>
<p>One way of achieving an atomic update is to have the three files in a common directory. This certificate directory is then made a symbolic link to the directory where the actual files are located. Upon update, a new directory is created and populated, and the old symbolic link is replace an atomic manner (i.e. with rename(2)).</p>
<h3><a class="anchor" id="tls_attr"></a>
TLS Socket Attributes</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute Name   </th><th class="markdownTableHeadNone">Socket Type   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.cert_file   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The leaf certificate file. For connection sockets, writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.key_file   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The leaf certificate private key file. For connection sockets, writable only at socket creation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tls.tc_file   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">RW   </td><td class="markdownTableBodyNone">The trusted CA certificates bundle. For connection sockets, writable only at socket creation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tls.peer_subject_key_id   </td><td class="markdownTableBodyNone">Connection   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">R   </td><td class="markdownTableBodyNone">The X509v3 Subject Key Identifier of the remote peer, or a zero-length string in case the TLS connection is not established.   </td></tr>
</table>
<p>In addition to the TLS-specific attributes, a TLS socket also has all the <a class="el" href="index.html#tcp_attr">TCP Socket Attributes</a>.</p>
<h2><a class="anchor" id="utls_transport"></a>
UTLS Transport</h2>
<p>The UTLS transport provides a hybrid transport, utilizing both the TLS and UX transports internally for actual connection establishment and message delivery.</p>
<p>On the client side, at the time of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, the UTLS transport determines if the server socket can be reached by using the UX transport (i.e. if the server socket is located on the same OS instance, in the same network namespace). If not, UTLS will attempt to reach the server by means of the TLS transport.</p>
<p>For a particular UTLS connection, either TLS or UX is used (never both). XCM connections to a particular UTLS server socket may be a mix of the two different types.</p>
<p>For an UTLS server socket with the address <code>utls:&lt;ip&gt;:&lt;port&gt;</code>, two underlying addresses will be allocated; <code>tls:&lt;ip&gt;:&lt;port&gt;</code> and <code>ux:&lt;ip&gt;:&lt;port&gt;</code>.</p>
<p>In case DNS is used: <code>tls:&lt;hostname&gt;:&lt;port&gt;</code> and <code>ux:&lt;hostname&gt;:&lt;port&gt;</code>.</p>
<h3><a class="anchor" id="utls_limitations"></a>
UTLS Limitations</h3>
<p>A wildcard should never be used when creating a UTLS server socket.</p>
<p>If a DNS hostname is used in place of the IP address, both the client and server need employ DNS, and also agree upon which hostname to use (in case there are several pointing at the same IP address).</p>
<p>Failure to adhere to the above two rules will prevent a client from finding a local server. Such a client will instead establish a TLS connection to the server.</p>
<h2><a class="anchor" id="sctp_transport"></a>
SCTP Transport</h2>
<p>The SCTP transport uses the Stream Control Transmission Protocol (SCTP). SCTP provides a reliable, message-oriented service. In-order delivery is optional, but to adhere to XCM semantics (and for other reasons) XCM leaves SCTP in-order delivery enabled.</p>
<p>The SCTP transport utilizes the native Linux kernel's implementation of SCTP, via the BSD Socket API. The operating mode is such that there is a 1:1-mapping between an association and a socket (fd).</p>
<p>The SCTP transport supports IPv4 and IPv6.</p>
<p>To minimize latency, the SCTP transport disables the Nagle algorithm.</p>
<h1><a class="anchor" id="namespaces"></a>
Linux Network and IPC Namespaces</h1>
<p>Namespaces is a Linux kernel facility concept for creating multiple, independent namespaces for kernel resources of a certain kind.</p>
<p>Linux Network Namespaces will affect all transports, including the UX transport.</p>
<p>XCM has no explicit namespace support. Rather, the application is expected to use the Linux kernel facilities for this functionality (i.e. switch to the right namespace before <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> och <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>).</p>
<p>In case the system follows the iproute2 conventions in regards to network namespace naming, the TLS and UTLS transports support per-network namespace TLS certificates and private keys.</p>
<h1><a class="anchor" id="limitations"></a>
Limitations</h1>
<p>XCM, in its current form, does not support binding to a local socket before doing connect() - something that is possible with BSD Sockets, but very rarely makes sense.</p>
<p>XCM also doesn't have a sendmmsg() or recvmmsg() equivalent. Those could easily be added, and would provide some major performance improvements for applications that are sending or receiving multiple messages on the same connection on the same time. *mmsg() equivalents have been left out because there are strong doubts there are such applications. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 30 2025 11:07:03 for Extensible Connection-oriented Messaging (XCM) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
