<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extensible Connection-oriented Messaging (XCM): include/xcm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extensible Connection-oriented Messaging (XCM)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">xcm.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the core Extensible Connection-oriented Messaging (XCM) API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;<a class="el" href="xcm__attr__map_8h_source.html">xcm_attr_map.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="xcm__compat_8h_source.html">xcm_compat.h</a>&gt;</code><br />
</div>
<p><a href="xcm_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5741d65a6840a49421f076e1abc69a1c" id="r_a5741d65a6840a49421f076e1abc69a1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="separator:a5741d65a6840a49421f076e1abc69a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3429d5eebf90c5572549d77a3d08f2f" id="r_aa3429d5eebf90c5572549d77a3d08f2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#aa3429d5eebf90c5572549d77a3d08f2f">XCM_SO_RECEIVABLE</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="separator:aa3429d5eebf90c5572549d77a3d08f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864b4817dbcca717b5b9778d2c6deac3" id="r_a864b4817dbcca717b5b9778d2c6deac3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a864b4817dbcca717b5b9778d2c6deac3">XCM_SO_SENDABLE</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="separator:a864b4817dbcca717b5b9778d2c6deac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6835d2d195427b0748c9c2fd782596f2" id="r_a6835d2d195427b0748c9c2fd782596f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6835d2d195427b0748c9c2fd782596f2">XCM_SO_ACCEPTABLE</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="separator:a6835d2d195427b0748c9c2fd782596f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae20ec97fe774a1d92e3fde4ec1d4aa91" id="r_ae20ec97fe774a1d92e3fde4ec1d4aa91"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect</a> (const char *remote_addr, int flags)</td></tr>
<tr class="separator:ae20ec97fe774a1d92e3fde4ec1d4aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e67bc6e21a33371bd273e089d6d741" id="r_ae8e67bc6e21a33371bd273e089d6d741"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a</a> (const char *remote_addr, const struct xcm_attr_map *attrs)</td></tr>
<tr class="separator:ae8e67bc6e21a33371bd273e089d6d741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dd2ff0e70e5658200fe574ee44eba2" id="r_ab6dd2ff0e70e5658200fe574ee44eba2"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server</a> (const char *local_addr)</td></tr>
<tr class="separator:ab6dd2ff0e70e5658200fe574ee44eba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b334574c9e1b15af4c0350d8b7cf9ad" id="r_a6b334574c9e1b15af4c0350d8b7cf9ad"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6b334574c9e1b15af4c0350d8b7cf9ad">xcm_server_a</a> (const char *local_addr, const struct xcm_attr_map *attrs)</td></tr>
<tr class="separator:a6b334574c9e1b15af4c0350d8b7cf9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5449c1b0818cf422cffe799872a570" id="r_abb5449c1b0818cf422cffe799872a570"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:abb5449c1b0818cf422cffe799872a570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74466386ee40c9e5992940822b4ec02" id="r_ab74466386ee40c9e5992940822b4ec02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:ab74466386ee40c9e5992940822b4ec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b0002316159f9d968c4e361c859542" id="r_a88b0002316159f9d968c4e361c859542"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept</a> (struct xcm_socket *server_socket)</td></tr>
<tr class="separator:a88b0002316159f9d968c4e361c859542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fa917f8db95f009a917dc593d21986" id="r_ad4fa917f8db95f009a917dc593d21986"><td class="memItemLeft" align="right" valign="top">struct xcm_socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ad4fa917f8db95f009a917dc593d21986">xcm_accept_a</a> (struct xcm_socket *server_socket, const struct xcm_attr_map *attrs)</td></tr>
<tr class="separator:ad4fa917f8db95f009a917dc593d21986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a888c879430f4fd51ccf43d6cec344" id="r_ac1a888c879430f4fd51ccf43d6cec344"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send</a> (struct xcm_socket *conn_socket, const void *buf, size_t len)</td></tr>
<tr class="separator:ac1a888c879430f4fd51ccf43d6cec344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b290a1b9e5a806c955322883481d29" id="r_a01b290a1b9e5a806c955322883481d29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive</a> (struct xcm_socket *conn_socket, void *buf, size_t capacity)</td></tr>
<tr class="separator:a01b290a1b9e5a806c955322883481d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad43ceebe461d6f361bc8f11d5dd463" id="r_a0ad43ceebe461d6f361bc8f11d5dd463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await</a> (struct xcm_socket *socket, int condition)</td></tr>
<tr class="separator:a0ad43ceebe461d6f361bc8f11d5dd463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9fe2b8cf695cd7b9cf30d01d12d4c" id="r_a11d9fe2b8cf695cd7b9cf30d01d12d4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a11d9fe2b8cf695cd7b9cf30d01d12d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6a75d0f3a97207beb406cd6787df4" id="r_a93e6a75d0f3a97207beb406cd6787df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a93e6a75d0f3a97207beb406cd6787df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae833dd506b15de04445e3a8331ad36bf" id="r_ae833dd506b15de04445e3a8331ad36bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking</a> (struct xcm_socket *socket, bool should_block)</td></tr>
<tr class="separator:ae833dd506b15de04445e3a8331ad36bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfdb3e1a859549d686c93b32c6a6818" id="r_a6cfdb3e1a859549d686c93b32c6a6818"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6cfdb3e1a859549d686c93b32c6a6818">xcm_is_blocking</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a6cfdb3e1a859549d686c93b32c6a6818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150197cffea9d5ff610bb856b5fd2de" id="r_a6150197cffea9d5ff610bb856b5fd2de"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr</a> (struct xcm_socket *conn_socket)</td></tr>
<tr class="separator:a6150197cffea9d5ff610bb856b5fd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fefa1353b41c2445e13603e80f56336" id="r_a7fefa1353b41c2445e13603e80f56336"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcm_8h.html#a7fefa1353b41c2445e13603e80f56336">xcm_local_addr</a> (struct xcm_socket *socket)</td></tr>
<tr class="separator:a7fefa1353b41c2445e13603e80f56336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the core Extensible Connection-oriented Messaging (XCM) API. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5741d65a6840a49421f076e1abc69a1c" name="a5741d65a6840a49421f076e1abc69a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5741d65a6840a49421f076e1abc69a1c">&#9670;&#160;</a></span>XCM_NONBLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_NONBLOCK&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag used in <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> </p>

</div>
</div>
<a id="aa3429d5eebf90c5572549d77a3d08f2f" name="aa3429d5eebf90c5572549d77a3d08f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3429d5eebf90c5572549d77a3d08f2f">&#9670;&#160;</a></span>XCM_SO_RECEIVABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_SO_RECEIVABLE&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a socket where the application likely can receive data. </p>

</div>
</div>
<a id="a864b4817dbcca717b5b9778d2c6deac3" name="a864b4817dbcca717b5b9778d2c6deac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864b4817dbcca717b5b9778d2c6deac3">&#9670;&#160;</a></span>XCM_SO_SENDABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_SO_SENDABLE&#160;&#160;&#160;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a socket where the application likely can send data. </p>

</div>
</div>
<a id="a6835d2d195427b0748c9c2fd782596f2" name="a6835d2d195427b0748c9c2fd782596f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6835d2d195427b0748c9c2fd782596f2">&#9670;&#160;</a></span>XCM_SO_ACCEPTABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCM_SO_ACCEPTABLE&#160;&#160;&#160;(1&lt;&lt;2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag bit denoting a socket with a pending incoming connection. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae20ec97fe774a1d92e3fde4ec1d4aa91" name="ae20ec97fe774a1d92e3fde4ec1d4aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20ec97fe774a1d92e3fde4ec1d4aa91">&#9670;&#160;</a></span>xcm_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to a remote server socket.</p>
<p>This function returns a connection socket, which is used to send messages to, and receive messages from the server.</p>
<p>In BSD Sockets terms, this call does both socket() and connect().</p>
<p>By default, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> blocks for the time it takes for the transport to determine if the named remote endpoint exists, and is responding (including any initial handshaking, key exchange etc). If the remote server socket is not yet bound, it's up to the application to retry.</p>
<p>If the XCM_NONBLOCK flag is set, <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> will work in a non-blocking fashion and will always return immediately, either leaving the connection socket in a connected state, a partly connected state, or signaling an error.</p>
<p>Setting XCM_NONBLOCK will leave the connection in non-blocking mode (see <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> for details).</p>
<p>See <a class="el" href="index.html#select">Event-driven Programming Support</a> for an overview how non-blocking mode is used.</p>
<p>For non-blocking connection establishment attempts, the application may use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> the query the result. It should use <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> and select() to wait for the appropriate time to make the <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> call (although it may be called at any point).</p>
<p><a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> with the XCM_NONBLOCK flag set will leave the connection in non-blocking mode (see <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a> for details).</p>
<p>Since the "xcm.service" attribute defaults to "messaging", this function cannot be used to create connectionx sockets with the byte stream service type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>The remote address which to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Either 0, or XCM_NONBLOCK for a non-blocking connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a socket reference on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">Invalid address format.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ENOPROTOOPT   </td><td class="markdownTableBodyNone">Transport protocol not available.   </td></tr>
</table>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for other possible errno values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close</a> </dd></dl>

</div>
</div>
<a id="ae8e67bc6e21a33371bd273e089d6d741" name="ae8e67bc6e21a33371bd273e089d6d741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e67bc6e21a33371bd273e089d6d741">&#9670;&#160;</a></span>xcm_connect_a()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_connect_a </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xcm_attr_map *&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to a remote server socket, with attributes.</p>
<p>This function is equivalent to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, only it also allows the caller to specify a set of <a class="el" href="index.html#attributes">Socket Attributes</a> to be applied as a part of the connection establishment.</p>
<p>The primary reasons for this function is to allow setting attributes that needs to be set prior to, or during, actual connection establishment. In addition, <a class="el" href="xcm_8h.html#ae8e67bc6e21a33371bd273e089d6d741">xcm_connect_a()</a> serves as a convenience function, letting applications avoid repeated <a class="el" href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set()</a> calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>The remote address which to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attrs</td><td>A set of attributes to be applied to the connection socket, or NULL. Only accessed during the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a socket reference on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<p>See <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> and <a class="el" href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set()</a> for possible errno values. </p>

</div>
</div>
<a id="ab6dd2ff0e70e5658200fe574ee44eba2" name="ab6dd2ff0e70e5658200fe574ee44eba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dd2ff0e70e5658200fe574ee44eba2">&#9670;&#160;</a></span>xcm_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_server </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>local_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a server socket and binds it to a specific address.</p>
<p>This function creates a server socket and binds it to a specific address. After this call has completed, clients may connect to the address specified.</p>
<p>This call is the equivalent of socket()+bind()+listen() in BSD Sockets. In case remote_addr has a DNS domain name (as opposed to an IP address), a <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> call also includes a blocking name resolution (e.g. gethostbyname()).</p>
<p>Since the "xcm.service" attribute defaults to "messaging", this function cannot be used to create server sockets with the byte stream service type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_addr</td><td>The local address to which this socket should be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a server socket reference on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EACCESS   </td><td class="markdownTableBodyNone">Permission to create the socket was denied.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EADDRINUSE   </td><td class="markdownTableBodyNone">Local socket address is already in use.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOMEM   </td><td class="markdownTableBodyNone">Insufficient memory.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">Invalid address format.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOPROTOOPT   </td><td class="markdownTableBodyNone">Transport protocol not available.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EMFILE   </td><td class="markdownTableBodyNone">The per-process limit on the number of open file descriptors has been reached.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENFILE   </td><td class="markdownTableBodyNone">The limit on the total number of open file descriptors has been reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EPROTO   </td><td class="markdownTableBodyNone">A protocol error occured.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOENT   </td><td class="markdownTableBodyNone">DNS domain name resolution failed.   </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close</a> </dd></dl>

</div>
</div>
<a id="a6b334574c9e1b15af4c0350d8b7cf9ad" name="a6b334574c9e1b15af4c0350d8b7cf9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b334574c9e1b15af4c0350d8b7cf9ad">&#9670;&#160;</a></span>xcm_server_a()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_server_a </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xcm_attr_map *&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and binds to a server socket, with attributes.</p>
<p>This function is equivalent to <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a>, only it also allows the caller to specify a set of <a class="el" href="index.html#attributes">Socket Attributes</a> to be applied as a part of server socket creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_addr</td><td>The local address to which this socket should be bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attrs</td><td>A set of attributes to be applied to the socket, or NULL. Only accessed during the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a server socket reference on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<p>See <a class="el" href="xcm_8h.html#ab6dd2ff0e70e5658200fe574ee44eba2">xcm_server()</a> and <a class="el" href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set()</a> for possible errno values. </p>

</div>
</div>
<a id="abb5449c1b0818cf422cffe799872a570" name="abb5449c1b0818cf422cffe799872a570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5449c1b0818cf422cffe799872a570">&#9670;&#160;</a></span>xcm_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_close </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an endpoint.</p>
<p>This function close a XCM socket, including both signaling to the far and freeing of any local resources associated with this socket.</p>
<p><a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a> will not block, and applications wanting to finish any outstanding tasks on a socket in non-blocking mode should use <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket to be closed, or NULL (in case <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a> is a no-operation).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup</a> </dd></dl>

</div>
</div>
<a id="ab74466386ee40c9e5992940822b4ec02" name="ab74466386ee40c9e5992940822b4ec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74466386ee40c9e5992940822b4ec02">&#9670;&#160;</a></span>xcm_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xcm_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up any local resources tied to a XCM socket not owned by the caller process.</p>
<p>After a fork() call, either of the two processes (the parent, or the child) must be designated the owner of every XCM socket the parent owned.</p>
<p>The owner may continue to use the XCM socket normally.</p>
<p>The non-owner may use <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a> to free any local memory tied to this socket, without impacting the connection state in the owner process.</p>
<p>The non-owner may not call <a class="el" href="xcm_8h.html#abb5449c1b0818cf422cffe799872a570">xcm_close()</a> or any other XCM API call.</p>
<p>The owner may not call <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket which local resources are to be freed, or NULL (in case <a class="el" href="xcm_8h.html#ab74466386ee40c9e5992940822b4ec02">xcm_cleanup()</a> is a no-operation). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b0002316159f9d968c4e361c859542" name="a88b0002316159f9d968c4e361c859542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b0002316159f9d968c4e361c859542">&#9670;&#160;</a></span>xcm_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_accept </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>server_socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a pending incoming connection from the server socket's queue.</p>
<p><a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> retrieves the first connection request from the server socket's queue of pending connections.</p>
<p>In case the server socket is in non-blocking mode, the XCM connection socket returned from <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> will also be in non-blocking mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">server_socket</td><td>The server socket on which to attempt to accept one pending connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a newly created XCM connection socket on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for possible errno values. </p>

</div>
</div>
<a id="ad4fa917f8db95f009a917dc593d21986" name="ad4fa917f8db95f009a917dc593d21986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fa917f8db95f009a917dc593d21986">&#9670;&#160;</a></span>xcm_accept_a()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xcm_socket * xcm_accept_a </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>server_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xcm_attr_map *&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a pending incoming connection, with attributes.</p>
<p>This function is equivalent to <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, only it also allows the caller to specify a set of <a class="el" href="index.html#attributes">Socket Attributes</a> to be applied as a part of accepting the new connection socket.</p>
<p>Such attributes will override any value inherited from the server socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">server_socket</td><td>The server socket on which to attempt to accept one pending connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attrs</td><td>A set of attributes to be applied to the socket, or NULL. Only accessed during the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a newly created XCM connection socket on success, or NULL if an error occured (in which case errno is set).</dd></dl>
<p>See <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> and <a class="el" href="xcm__attr_8h.html#a182c1e6606a5481e6d10693a7b2db839">xcm_attr_set()</a> for possible errno values. </p>

</div>
</div>
<a id="ac1a888c879430f4fd51ccf43d6cec344" name="ac1a888c879430f4fd51ccf43d6cec344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a888c879430f4fd51ccf43d6cec344">&#9670;&#160;</a></span>xcm_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_send </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>conn_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send message on a particular connection.</p>
<p>The <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> function is used to send a message (or a sequence of bytes, for byte stream transports) out on a connection socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_socket</td><td>The connection socket the data will be sent on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A pointer to the data buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of the buffer in bytes. Zero-length buffers are not allowed for messaging type transports.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>For messaging transports, 0 is returned on success. For byte stream transports, the number of bytes accepted into the XCM layer is returned (which may be shorter than len, but which is always greater than zero). In case of an error, -1 is returned (and errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EMSGSIZE   </td><td class="markdownTableBodyNone">Message is too large. See also the maximum size attribute in <a class="el" href="index.html#xcm_attr">Generic Attributes</a>. Only applicable to messaging transports.   </td></tr>
</table>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for more errno values. </p>

</div>
</div>
<a id="a01b290a1b9e5a806c955322883481d29" name="a01b290a1b9e5a806c955322883481d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b290a1b9e5a806c955322883481d29">&#9670;&#160;</a></span>xcm_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_receive </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>conn_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive message on a particular connection.</p>
<p>The <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> function is used to receive data on a connection socket. For messaging type transport connections, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> produces at most one message, in its entirety. For byte stream transports, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> returns a sequence of bytes.</p>
<p>If the connection is of the messaging service type and the capacity of the user-supplied buffer is smaller than the actual message length, the message will be truncated and the part that fits will be stored in the buffer. The return value will be the length of the truncated message (i.e. the capacity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_socket</td><td>The connection socket the data will receive be on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>The user-supplied buffer where the incoming data will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity in bytes of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the amount (&gt; 0 bytes) of data stored in the buffer, 0 if the remote end has closed the connection, or -1 if an error occured (in which case errno is set).</dd></dl>
<p>See <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> for possible errno values. </p>

</div>
</div>
<a id="a0ad43ceebe461d6f361bc8f11d5dd463" name="a0ad43ceebe461d6f361bc8f11d5dd463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad43ceebe461d6f361bc8f11d5dd463">&#9670;&#160;</a></span>xcm_await()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_await </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inform socket of which operations the application is waiting to perform.</p>
<p>This function is only used by event-driven application and with XCM sockets in non-blocking mode. For an overview on this subject, see <a class="el" href="index.html#select">Event-driven Programming Support</a>.</p>
<p>Using <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a>, the application informs the XCM socket what conditions it's waiting for (i.e. what XCM operations it wants to perform). These conditions are stored in the socket, and won't change until the application calls <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> again.</p>
<p>The <code>condition</code> parameter is a bitmask, with the valid bits being <a class="el" href="xcm_8h.html#aa3429d5eebf90c5572549d77a3d08f2f">XCM_SO_RECEIVABLE</a> or <a class="el" href="xcm_8h.html#a864b4817dbcca717b5b9778d2c6deac3">XCM_SO_SENDABLE</a> (for connection socket) or <a class="el" href="xcm_8h.html#a6835d2d195427b0748c9c2fd782596f2">XCM_SO_ACCEPTABLE</a> (for server sockets). If no bits are set, the application is not interested in anything beyond the XCM socket to finish any outstanding tasks.</p>
<p>Typically, the application would call <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> when an XCM operation (such as <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>) has failed with errno set to EAGAIN. However, the application may also call <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> even though neither <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>, nor <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> has failed in such a manner.</p>
<p>In case any of the conditions the application is asking for are believed to be met already at the time of the <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> call, the XCM socket fd (see <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> for details) will be marked as ready to be read.</p>
<p>The conditions specified by the application are future operation it wishes to perform on a socket (as opposed to finishing operations the socket has already accepted). For example, if an application use <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> to transmit a message, and the XCM socket accept this request (by returning 0 on the call), the application shouldn't send <a class="el" href="xcm_8h.html#a864b4817dbcca717b5b9778d2c6deac3">XCM_SO_SENDABLE</a> flag for the reason of having XCM finishing the transmission; the task of actually handing over message to the lower layer is performed by XCM regardless of the conditions specified.</p>
<p>Even though XCM socket fd is marked readable (by select()), and thus the application-specified conditions for a particular connection socket are likely met, there's no guarantee that the API operation (i.e. <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>) will succeed.</p>
<p>If an application is waiting for both XCM_SO_SENDABLE and XCM_SO_RECEIVABLE, is should try both to send and receive when the socket fd is marked readable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The XCM socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The condition the application is waiting for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the XCM socket fd on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">The socket is not in non-blocking mode, or the condition bits are invalid.   </td></tr>
</table>

</div>
</div>
<a id="a11d9fe2b8cf695cd7b9cf30d01d12d4c" name="a11d9fe2b8cf695cd7b9cf30d01d12d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d9fe2b8cf695cd7b9cf30d01d12d4c">&#9670;&#160;</a></span>xcm_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_fd </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns XCM socket fd.</p>
<p>This call retrieves the XCM socket fd for a XCM socket non-blocking mode.</p>
<p>When this fd becomes readable, the XCM socket is ready to make progress.</p>
<p>Progress can mean both progress toward the goal of reaching the application's desired socket condition (see <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a> for details), or finishing any outstanding task the XCM socket has.</p>
<p>Please note that the XCM socket fd is <b>only</b> ever marked readable (as opposed to writable). This is true even if the application is waiting to send a message on the socket. Marked readable means that the fd is, for example, marked with EPOLLIN, in case epoll_wait() is used, or has its bit set in the <code>readfs</code> fd_set, in case select() is used.</p>
<p>When the XCM socket fd becomes readable, an application would typically perform the actions it specified in <a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await()</a>'s condition parameter. It is not forced to do so, but may choose to perform other API operations instead. However, if neither <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> nor <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> is called, the application must call <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>. The <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> call must be made, even though the <code>condition</code> parameter was set to zero. This is to allow the socket make progress on its background tasks. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The connection or server socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EINVAL   </td><td class="markdownTableBodyNone">The socket is not in non-blocking mode.   </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#a0ad43ceebe461d6f361bc8f11d5dd463">xcm_await</a> </dd></dl>

</div>
</div>
<a id="a93e6a75d0f3a97207beb406cd6787df4" name="a93e6a75d0f3a97207beb406cd6787df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6a75d0f3a97207beb406cd6787df4">&#9670;&#160;</a></span>xcm_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_finish </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to finish an ongoing non-blocking background operation.</p>
<p>This call is used by an application having issued <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> with the XCM_NONBLOCK flag set, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> or <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> call on a connection socket in non-blocking mode, wishing to finish outstanding processing related to that operation, to know if it succeeded or not.</p>
<p>In addition, <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> must be called if the conditions on a non-blocking socket are met (as signaled by select() marking the socket fd returned by <a class="el" href="xcm_8h.html#a11d9fe2b8cf695cd7b9cf30d01d12d4c">xcm_fd()</a> as readable), unless the application calls <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> or <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> on that socket. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for details.</p>
<p><a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a> may be called at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The connection or server socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the connection has been successfully been established, or -1 if it has not (in which case errno is set).</dd></dl>
<p>These errno values are possible not only for <a class="el" href="xcm_8h.html#a93e6a75d0f3a97207beb406cd6787df4">xcm_finish()</a>, but also for <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a>, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a>, and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EPIPE   </td><td class="markdownTableBodyNone">The connection is closed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EAGAIN   </td><td class="markdownTableBodyNone">The socket is marked non-blocking (with <a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking()</a>) and the requested operation would block.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ECONNRESET   </td><td class="markdownTableBodyNone">Connection reset by peer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ECONNREFUSED   </td><td class="markdownTableBodyNone">No-one is listening on the remote address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ECONNABORTED   </td><td class="markdownTableBodyNone">A connection has been aborted due to host-internal reasons.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EHOSTUNREACH   </td><td class="markdownTableBodyNone">Remote host is unreachable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENETUNREACH   </td><td class="markdownTableBodyNone">Network is unreachable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ETIMEDOUT   </td><td class="markdownTableBodyNone">No or lost network connectivity.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOMEM   </td><td class="markdownTableBodyNone">Insufficient memory (or other resources) to perform operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EINTR   </td><td class="markdownTableBodyNone">The operation was interrupted by a UNIX signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EPROTO   </td><td class="markdownTableBodyNone">A non-recoverable protocol error occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EMFILE   </td><td class="markdownTableBodyNone">The per-process limit on the number of open file descriptors has been reached.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENFILE   </td><td class="markdownTableBodyNone">The limit on the total number of open file descriptors has been reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EACCES   </td><td class="markdownTableBodyNone">Permission to create the socket was denied.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOENT   </td><td class="markdownTableBodyNone">DNS domain name resolution failed.   </td></tr>
</table>

</div>
</div>
<a id="ae833dd506b15de04445e3a8331ad36bf" name="ae833dd506b15de04445e3a8331ad36bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae833dd506b15de04445e3a8331ad36bf">&#9670;&#160;</a></span>xcm_set_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xcm_set_blocking </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enabled or disabled non-blocking operation on this socket.</p>
<p>In blocking mode (which is the default), <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> calls does not return until a message has been handed over to the system (in case of send), or received from the system (in case of receive), or an error has occured (whichever happens first).</p>
<p>In non-blocking mode, <a class="el" href="xcm_8h.html#ac1a888c879430f4fd51ccf43d6cec344">xcm_send()</a> and <a class="el" href="xcm_8h.html#a01b290a1b9e5a806c955322883481d29">xcm_receive()</a> will return immediately, regardless if XCM has been enable to fulfill the application's request or not.</p>
<p>Server sockets may also be set into non-blocking mode, in which case <a class="el" href="xcm_8h.html#a88b0002316159f9d968c4e361c859542">xcm_accept()</a> won't block.</p>
<p>Connection sockets created as a result of <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a> may be set into non-blocking mode already from the start, by means of the <a class="el" href="xcm_8h.html#a5741d65a6840a49421f076e1abc69a1c">XCM_NONBLOCK</a> flag to <a class="el" href="xcm_8h.html#ae20ec97fe774a1d92e3fde4ec1d4aa91">xcm_connect()</a>, in which case also the connection establishment process is non-blocking.</p>
<p>For an overview of the use of non-blocking mode, see <a class="el" href="index.html#select">Event-driven Programming Support</a>.</p>
<p>To set a non-blocking connection socket into blocking mode, it needs to have finished all outstanding tasks. See <a class="el" href="index.html#outstanding_tasks">Finishing Outstanding Tasks</a> for details.</p>
<p>Setting the "xcm.blocking" attribute is an alternative to using this function. See <a class="el" href="index.html#xcm_attr">Generic Attributes</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">should_block</td><td>Set to true for blocking operation, false for non-blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the 0 on success, or -1 if an error occured (in which case errno is set).</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EAGAIN   </td><td class="markdownTableBodyNone">The connection socket has unfinished work that needs to completed before mode can be switched.   </td></tr>
</table>

</div>
</div>
<a id="a6cfdb3e1a859549d686c93b32c6a6818" name="a6cfdb3e1a859549d686c93b32c6a6818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfdb3e1a859549d686c93b32c6a6818">&#9670;&#160;</a></span>xcm_is_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xcm_is_blocking </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query whether or not a socket is in non-blocking mode.</p>
<p>For an overview of the use of non-blocking mode, see <a class="el" href="index.html#select">Event-driven Programming Support</a>.</p>
<p>Reading the "xcm.blocking" attribute is an alternative to using this function. See <a class="el" href="index.html#xcm_attr">Generic Attributes</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>The socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the true if the socket is in blocking mode, or false if it is in non-blocking mode.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="xcm_8h.html#ae833dd506b15de04445e3a8331ad36bf">xcm_set_blocking</a> </dd></dl>

</div>
</div>
<a id="a6150197cffea9d5ff610bb856b5fd2de" name="a6150197cffea9d5ff610bb856b5fd2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6150197cffea9d5ff610bb856b5fd2de">&#9670;&#160;</a></span>xcm_remote_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xcm_remote_addr </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>conn_socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the remote endpoint for this connection.</p>
<p>This operation only works for sockets representing connections.</p>
<p>The address returned is in string format, and the pointer returned is to an buffer allocated as a part of the socket state, and need not and should not be free'd by the user.</p>
<p>Reading the "xcm.remote_addr" attribute is an alternative to using this function. See <a class="el" href="index.html#xcm_attr">Generic Attributes</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_socket</td><td>The connection socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the remote endpoint address, or NULL if an error occurred (in which case errno is set). </dd></dl>

</div>
</div>
<a id="a7fefa1353b41c2445e13603e80f56336" name="a7fefa1353b41c2445e13603e80f56336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fefa1353b41c2445e13603e80f56336">&#9670;&#160;</a></span>xcm_local_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xcm_local_addr </td>
          <td>(</td>
          <td class="paramtype">struct xcm_socket *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the local endpoint for this socket.</p>
<p>Just like <a class="el" href="xcm_8h.html#a6150197cffea9d5ff610bb856b5fd2de">xcm_remote_addr()</a>, but returns the local endpoint address.</p>
<p>This function applies to both server and connection sockets.</p>
<p>Reading the "xcm.local_addr" attribute is an alternative to using this function. See <a class="el" href="index.html#xcm_attr">Generic Attributes</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>A server or connection socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the local endpoint address, or NULL if an error occurred (in which case errno is set). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 30 2025 11:07:52 for Extensible Connection-oriented Messaging (XCM) by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
